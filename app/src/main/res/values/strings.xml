<resources>
    <string name="app_name">Python Education</string>
    <string name="logo">logo</string>

    <string name="lesson1">лекция 1</string>
    <string name="lesson2">лекция 2</string>
    <string name="lesson3">лекция 3</string>
    <string name="lesson4">лекция 4</string>
    <string name="lesson5">лекция 5</string>
    <string name="lesson6">лекция 6</string>
    <string name="lesson7">лекция 7</string>
    <string name="lesson8">лекция 8</string>
    <string name="lesson9">лекция 9</string>
    <string name="lesson10">лекция 10</string>

    <string name="startTest">пройти тест</string>

    <string name="lesson1_text">
        Лекция 1: Введение в программирование на языке Python\n\nЧто такое Python?\n\n
О Python (лучше произносить \"питон\", хотя некоторые говорят \"пайтон\") - предмете данного изучения, лучше всего говорит создатель этого языка программирования, голландец Гвидо ван Россум:
\n\"Python - интерпретируемый, объектно-ориентированный высокоуровневый язык программирования с динамической семантикой. Встроенные высокоуровневые структуры данных в сочетании с динамической типизацией и связыванием делают язык привлекательным для быстрой разработки приложений (RAD, Rapid Application Development). Кроме того, его можно использовать в качестве сценарного языка для связи программных компонентов. Синтаксис Python прост в изучении, в нем придается особое значение читаемости кода, а это сокращает затраты на сопровождение программных продуктов. Python поддерживает модули и пакеты, поощряя модульность и повторное использование кода. Интерпретатор Python и большая стандартная библиотека доступны бесплатно в виде исходных и исполняемых кодов для всех основных платформ и могут свободно распространяться.\"
\nВ процессе изучения будет раскрыт смысл этого определения, а сейчас достаточно знать, что Python - это универсальный язык программирования. Он имеет свои преимущества и недостатки, а также сферы применения. В поставку Python входит обширная стандартная библиотека для решения широкого круга задач. В Интернете доступны качественные библиотеки для Python по различным предметным областям: средства обработки текстов и технологии Интернет, обработка изображений, инструменты для создания приложений, механизмы доступа к базам данных, пакеты для научных вычислений, библиотеки построения графического интерфейса и т.п. Кроме того, Python имеет достаточно простые средства для интеграции с языками C, C++ (и Java) как путем встраивания (embedding) интерпретатора в программы на этих языках, так и наоборот, посредством использования библиотек, написанных на этих языках, в Python-программах. Язык Python поддерживает несколько парадигм программирования: императивное (процедурный, структурный, модульный подходы), объектно-ориентированное и функциональное программирование.
\nМожно считать, что Python - это целая технология для создания программных продуктов (и их прототипов). Она доступна почти на всех современных платформах (как 32-битных, так и на 64-битных) с компилятором C и на платформе Java.
\nМожет показаться, что, в программной индустрии нет места для чего-то другого кроме C/C++, Java, Visual Basic, C#. Однако это не так. Возможно, благодаря данному курсу лекций и практических занятий у Python появятся новые приверженцы, для которых он станет незаменимым инструментом.
\n\nИстория языка Python\n\n
Создание Python было начато Гвидо ван Россумом (Guido van Rossum) в 1991 году, когда он работал над распределенной ОС Амеба. Ему требовался расширяемый язык, который бы обеспечил поддержку системных вызовов. За основу были взяты ABC и Модула-3. В качестве названия он выбрал Python в честь комедийных серий BBC \"Летающий цирк Монти-Пайтона\", а вовсе не по названию змеи. С тех пор Python развивался при поддержке тех организаций, в которых Гвидо работал. Особенно активно язык совершенствуется в настоящее время, когда над ним работает не только команда создателей, но и целое сообщество программистов со всего мира. И все-таки последнее слово о направлении развития языка остается за Гвидо ван Россумом.
        \n\nПрограмма на Python\n\n
Программа на языке Python может состоять из одного или нескольких модулей. Каждый модуль представляет собой текстовый файл в кодировке, совместимой с 7-битной кодировкой ASCII. Для кодировок, использующих старший бит, необходимо явно указывать название кодировки. Например, модуль, комментарии или строковые литералы которого записаны в кодировке KOI8-R, должен иметь в первой или второй строке следующую спецификацию:
\n# -*- coding: koi8-r -*-
\nБлагодаря этой спецификации интерпретатор Python будет знать, как корректно переводить символы литералов Unicode-строк в Unicode. Без этой строки новые версии Python будут выдавать предупреждение на каждый модуль, в котором встречаются коды с установленным восьмым битом.
\nО том, как делать программу модульной, станет известно в следующих лекциях. В примерах ниже используются как фрагменты модулей, записанных в файл, так и фрагменты диалога с интерпретатором Python. Последние отличаются характерным приглашением >>>. Символ решетка ( # ) отмечает комментарий до конца строки.
\nПрограмма на Python, с точки зрения интерпретатора, состоит из логических строк. Одна логическая строка, как правило, располагается в одной физической, но длинные логические строки можно явно (с помощью обратной косой черты) или неявно (внутри скобок) разбить на несколько физических:
\nprint a, \" - очень длинная строка, которая не помещается в\", \\80, \"знакоместах\"
        \nПримечание:
\nВо всех примерах в основном используется \"официальный\" стиль оформления кода на Python в соответствии с документом \"Python Style Guide\", который можно найти на сайте http://python.org
\n\nОсновные алгоритмические конструкции
\nПредполагается, что слушатели уже умеют программировать хотя бы на уровне школьной программы, и потому вполне достаточно провести параллели между алгоритмическими конструкциями и синтаксисом Python. Кроме того, Python как правило не подводит интуицию программиста (по крайней мере, науке хорошо известны типичные ошибки начинающих программистов на Python), поэтому изучать синтаксис Python предпочтительнее на примерах, а не с помощью синтаксических диаграмм или форм Бэкуса-Наура.
\nПоследовательность операторов
\nПоследовательные действия описываются последовательными строками программы. Стоит, правда, добавить, что в программах важны отступы, поэтому все операторы, входящие в последовательность действий, должны иметь один и тот же отступ:
\na = 1
\nb = 2
\na = a + b
\nb = a - b
\na = a - b
\nprint (a, b)
\nЧто делает этот пример? Проверить свою догадку можно с помощью интерактивного режима интерпретатора Python.
\nПри работе с Python в интерактивном режиме как бы вводится одна большая программа, состоящая из последовательных действий. В примере выше использованы операторы присваивания и оператор print.
\nОператор условия и выбора
\nРазумеется, одними только последовательными действиями в программировании не обойтись, поэтому при написании алгоритмов используется еще и ветвление:
\nif a > b:
\n  c = a
\nelse:
\n  c = b
\nЭтот кусок кода на Python интуитивно понятен каждому, кто помнит, что if по-английски значит \"если\", а else - \"иначе\". Оператор ветвления имеет в данном случае две части, операторы каждой из которых записываются с отступом вправо относительно оператора ветвления. Более общий случай - оператор выбора - можно записать с помощью следующего синтаксиса (пример вычисления знака числа):
\nif a &lt; 0:
\n  s = -1
\nelif a == 0:
\n  s = 0
\nelse:
\n  s = 1
\nСтоит заметить, что elif - это сокращенный else if. Без сокращения пришлось бы применять вложенный оператор ветвления:
\nif a &lt; 0:
\n  s = -1
\nelse:
\n  if a == 0:
\n    s = 0
\n  else:
\n    s = 1
\nВ отличие от оператора print, оператор if-else - составной оператор.
\n\nЦиклы
\nТретьей необходимой алгоритмической конструкцией является цикл. С помощью цикла можно описать повторяющиеся действия. В Python имеются два вида циклов: цикл ПОКА (выполняется некоторое условие) и цикл ДЛЯ (всех значений последовательности). Следующий пример иллюстрирует цикл ПОКА на Python:
\ns = \"abcdefghijklmnop\"
\nwhile s != \"\":
\n  print (s)
\n  s = s[1:-1]
\nОператор while говорит интерпретатору Python: \"пока верно условие цикла, выполнять тело цикла\". В языке Python тело цикла выделяется отступом. Каждое исполнение тела цикла будет называться итерацией. В приведенном примере убирается первый и последний символ строки до тех пор, пока не останется пустая строка.
\nДля большей гибкости при организации циклов применяются операторы break (прервать) и continue (продолжить). Первый позволяет прервать цикл, а второй - продолжить цикл, перейдя к следующей итерации (если, конечно, выполняется условие цикла).
\nСледующий пример читает строки из файла и выводит те, у которых длина больше 5:
\nf = open(\"file.txt\", \"r\")
\nwhile f:
\n  l = f.readline()
\n  if not l:
\n    break
\n  if len(l) > 5:
\n    print l
\nf.close()
\nВ этом примере организован бесконечный цикл, который прерывается только при получении из файла пустой строки ( l ), что обозначает конец файла.
\nВ языке Python логическое значение несет каждый объект: нули, пустые строки и последовательности, специальный объект None и логический литерал False имеют значение \"ложь\", а прочие объекты значение \"истина\". Для обозначения истины обычно используется 1 или True.
\nПримечание:
\nЛитералы True и False для обозначения логических значений появились в Python 2.3.
\nЦикл for выполняет тело цикла для каждого элемента последовательности. В следующем примере выводится таблица умножения:
\nfor i in range(1, 10):
\n  for j in range(1, 10):
\n    print \"%2i\" % (i*j),
\n  print
\nЗдесь циклы for являются вложенными. Функция range() порождает список целых чисел из полуоткрытого интервала [1, 10). Перед каждой итерацией счетчик цикла получает очередное значение из этого списка. Полуоткрытые диапазоны общеприняты в Python. Считается, что их использование более удобно и вызывает меньше программистских ошибок. Например, range(len(s)) порождает список индексов для списка s (в Python-последовательности первый элемент имеет индекс 0 ). Для красивого вывода таблицы умножения применена операция форматирования % (для целых чисел тот же символ используется для обозначения операции взятия остатка от деления). Строка форматирования (задается слева) строится почти как строка форматирования для printf из C.
\n\nФункции
\nПрограммист может определять собственные функции двумя способами: с помощью оператора def или прямо в выражении, посредством lambda. Второй способ (да и вообще работа с функциями) будет рассмотрен подробнее в лекции по функциональному программированию на Python, а здесь следует привести пример определения и вызова функции:
\ndef cena(rub, kop=0):
\n  return \"%i руб. %i коп.\" % (rub, kop)
        \n\nprint cena(8, 50)
\nprint cena(7)
\nprint cena(rub=23, kop=70)
\nВ этом примере определена функция двух аргументов (из которых второй имеет значение по умолчанию - 0 ). Вариантов вызова этой функции с конкретными параметрами также несколько. Стоит только заметить, что при вызове функции сначала должны идти позиционные параметры, а затем, именованные. Аргументы со значениями по умолчанию должны следовать после обычных аргументов. Оператор return возвращает значение функции. Из функции можно возвратить только один объект , но он может быть кортежем из нескольких объектов.
\nПосле оператора def имя cena оказывается связанным с функциональным объектом.
\n\nИсключения
\nВ современных программах передача управления происходит не всегда так гладко, как в описанных выше конструкциях. Для обработки особых ситуаций (таких как деление на ноль или попытка чтения из несуществующего файла) применяется механизм исключений. Лучше всего пояснить синтаксис оператора try-except следующим примером:
\ntry:
\n  res = int(open(\'a.txt\').read()) / int(open(\'c.txt\').read())
\n  print res
\nexcept IOError:
\n  print \"Ошибка ввода-вывода\"
\nexcept ZeroDivisionError:
\n  print \"Деление на 0\"
\nexcept KeyboardInterrupt:
\n  print \"Прерывание с клавиатуры\"
\nexcept:
\n  print \"Ошибка\"
\nВ этом примере берутся числа из двух файлов и делятся одно на другое. В результате этих нехитрых действий может возникнуть несколько исключительных ситуаций, некоторые из них отмечены в частях except (здесь использованы стандартные встроенные исключения Python). Последняя часть except в этом примере улавливает все другие исключения, которые не были пойманы выше. Например, если хотя бы в одном из файлов находится нечисловое значение, функция int() возбудит исключение ValueError. Его-то и сможет отловить последняя часть except. Разумеется, выполнение части try в случае возникновения ошибки уже не продолжается после выполнения одной из частей except.
\nВ отличие от других языков программирования, в Python исключения нередко служат для упрощения алгоритмов. Записывая оператор try-except, программист может думать так: \"попробую, а если сорвется - выполнится код в except\". Особенно часто это используется для выражений, в которых значение получается по ключу из отображения:
\ntry:
\n  value = dict[key]
\nexcept:
\n  value = default_value
\nВместо
\nif dict.has_key(key):
\n  value = dict[key]
\nelse:
\n  value = default_value
\nПримечание:
\nПример уже несколько устаревшей идиомы языка Python иллюстрирует только дух этого подхода: в современном Python лучше записать так value = dict.get(key, default_value).
\nИсключения можно возбуждать и из программы. Для этого служит оператор raise. Заодно следующий пример показывает канонический способ определения собственного исключения:
\nclass MyError(Exception):
\n  pass
\ntry:
\n  \.\.\.
\n  raise MyError, \"my error 1\"
\n  \.\.\.
\nexcept MyError, x:
\n  print \"Ошибка:\", x
\nКстати, все исключения выстроены в иерархию классов, поэтому ZeroDivisionError может быть поймана как ArithmeticError, если соответствующая часть except будет идти раньше.
\nДля утверждений применяется специальный оператор assert. Он возбуждает AssertionError, если заданное в нем условие неверно. Этот оператор используют для самопроверки программы. В оптимизированном коде он не выполняется, поэтому строить на нем логику алгоритма нельзя. Пример:
\nc = a + b
\nassert c == a + b
\nКроме описанной формы оператора, есть еще форма try-finally для гарантированного выполнения некоторых действий при передаче управления изнутри оператора try-finally вовне. Он может применяться для освобождения занятых ресурсов, что требует обязательного выполнения, независимо от произошедших внутри катаклизмов:
\ntry:
\n  \.\.\.
\nfinally:
\n  print \"Обработка гарантированно завершена\"</string>


    <string name="lesson2_text">
        Лекция №2: Встроенные типы данных и выражения в Python\n\n
        Как уже говорилось, все данные в Python представлены объектами. Имена являются лишь ссылками на эти объекты и не несут нагрузки по декларации типа. Значения встроенных типов имеют специальную поддержку в синтаксисе языка: можно записать литерал строки, числа, списка, кортежа, словаря (и их разновидностей). Синтаксическую же поддержку операций над встроенными типами можно легко сделать доступной и для объектов определяемых пользователями классов.
\nСледует также отметить, что объекты могут быть неизменчивыми и изменчивыми. Например, строки в Python являются неизменчивыми, поэтому операции над строками создают новые строки.
\nКарта встроенных типов (с именами функций для приведения к нужному типу и именами классов для наследования от этих типов):
\n•	специальные типы: None, NotImplemented и Ellipsis ;
\n•	числа:
\n   - целые:
\n      1) обычное целое int
\n      2) целое произвольной точности long
\n      3) логический bool
\n   - число с плавающей точкой float
\n   - комплексное число complex
\n•	последовательности;
\n   - неизменчивые:
\n      1) строка str
\n      2) Unicode-строка unicode
\n      3) кортеж tuple
\n   - изменчивые:
\n      1) список list
\n•	отображения:
\n   - словарь dict
\n•	объекты, которые можно вызвать:
\n   - функции (пользовательские и встроенные)
\n   - функции-генераторы
\n   - методы (пользовательские и встроенные)
\n   - классы (новые и \"классические\")
\n   - экземпляры классов (если имеют метод __call__ )
\n•	модули;
\n•	классы (см. выше);
\n•	экземпляры классов (см. выше);
\n•	файлы file;
\n•	вспомогательные типы buffer, slice.
\nУзнать тип любого объекта можно с помощью встроенной функции type().
\n\nТип int и long
\nДва типа: int (целые числа) и long (целые произвольной точности) служат моделью для представления целых чисел. Первый соответствует типу long в компиляторе C для используемой архитектуры. Числовые литералы можно записать в системах счисления с основанием 8, 10 или 16:
\n# В этих литералах записано число 10
\nprint 10, 012, 0xA, 10L
\nСтоит заметить, что если в результате операции получается значение, выходящее за рамки допустимого, тип int может быть неявно преобразован в long:
\n>>> type(-2147483648)
\n&lt;type \'int\'>
\n>>> type(-2147483649)
\n&lt;type \'long\'>
\nТакже нужно быть осторожным при записи констант. Нули в начале числа - признак восьмеричной системы счисления, в которой нет цифры 8:
\n>>> 008
\n  File \"&lt;stdin>\", line 1
\n    008
\n      ^
\nSyntaxError: invalid token
\n\nТип float
\nСоответствует C-типу double для используемой архитектуры. Записывается вполне традиционным способом либо через точку, либо в нотации с экспонентой:
\n>>> pi = 3.1415926535897931
\n>>> pi ** 40
\n7.6912142205156999e+19
\nКроме арифметических операций, можно использовать операции из модуля math.
\nПримечание:
\nДля финансовых расчетов лучше применять более подходящий тип.
\nИз полезных встроенных функций можно вспомнить round(), abs().
\n\nТип complex
\nЛитерал мнимой части задается добавлением j в качестве суффикса (перемножаются мнимые единицы):
\n>>> -1j * -1j
\n(-1-0j)
\nТип реализован на базе вещественного. Кроме арифметических операций, можно использовать операции из модуля cmath.
\n\nТип bool
\nПодтип целочисленного типа для \"канонического\" обозначения логических величин. Два значения: True (истина) и False (ложь) - вот и все, что принадлежит этому типу.
\nСледует отметить, что Python даже не вычисляет второй операнд операции and или or, если ее исход ясен по первому операнду. Таким образом, если первый операнд истинен, он и возвращается как результат or, в противном случае возвращается второй операнд. Для операции and все аналогично.
\n\nТип string и тип unicode
\nВ Python строки бывают двух типов: обычные и Unicode-строки. Фактически строка - это последовательность символов (в случае обычных строк можно сказать \"последовательность байтов\"). Строки-константы можно задать в программе с помощью строковых литералов. Для литералов наравне используются как апострофы ( \' ), так и обычные двойные кавычки ( \" ). Для многострочных литералов можно использовать утроенные апострофы или утроенные кавычки. Управляющие последовательности внутри строковых литералов задаются обратной косой чертой ( \\ ).
\nДля строк имеется еще одна разновидность: необработанные строковые литералы. В этих литералах обратная косая черта и следующие за ней символы не интерпретируются как спецсимволы, а вставляются в строку \"как есть\":
\nmy_re = r\"(\\d)=\\1\"
\nОбычно такие строки требуются для записи регулярных выражений (о них пойдет речь в лекции, посвященной обработке текстовой информации).
\nНабор операций над строками включает конкатенацию \" + \", повтор \" * \", форматирование \" % \". Также строки имеют большое количество методов, некоторые из которых приведены ниже. Полный набор методов (и их необязательных аргументов) можно получить в документации по Python.
\n>>> \"A\" + \"B\"
\n\'AB\'
\n>>> \"A\"*10
\n\'AAAAAAAAAA\'
\n>>> \"%s %i\" % (\"abc\", 12)
\n\'abc 12\'
\nНекоторые методы строковых объектов будут рассмотрены в лекции, посвященной обработке текстов.
\n\nТип tuple
\nДля представления константной последовательности (разнородных) объектов используется тип кортеж. Литерал кортежа обычно записывается в круглых скобках, но можно, если не возникают неоднозначности, писать и без них.
\nИспользовать синтаксис кортежей можно и в левой части оператора присваивания. В этом случае на основе вычисленных справа значений формируется кортеж и связывается один в один с именами в левой части. Поэтому обмен значениями записывается очень изящно:
\na, b = b, a
\n\nТип list
\nВ \"чистом\" Python нет массивов с произвольным типом элемента. Вместо них используются списки. Их можно задать с помощью литералов, записываемых в квадратных скобках, или посредством списковых включений. Варианты задания списка приведены ниже:
\nlst1 = [1, 2, 3,]
\nlst2 = [x**2 for x in range(10) if x % 2 == 1]
\nlst3 = list(\"abcde\")
\nДля работы со списками существует несколько методов, дополнительных к тем, что имеют неизменчивые последовательности. Все они связаны с изменением списка.
\n\nПоследовательности
\nНиже обобщены основные методы последовательностей. Следует напомнить, что последовательности бывают неизменчивыми и изменчивыми. У последних методов чуть больше.
\nlen(s)	Длина последовательности s
\nx in s	Проверка принадлежности элемента последовательности. В новых версиях Python можно проверять принадлежность подстроки строке. Возвращает True или False
\nx not in s	= not x in s
\ns + s1	Конкатенация последовательностей
\ns*n или n*s	Последовательность из n раз повторенной s. Если n &lt; 0, возвращается пустая последовательность.
\ns[i]	Возвращает i-й элемент s или len(s)+i-й, если i &lt; 0
\ns[i:j:d]	Срез из последовательности s от i до j с шагом d будет рассматриваться ниже
\nmin(s)	Наименьший элемент s
\nmax(s)	Наибольший элемент s
\nДополнительные конструкции для изменчивых последовательностей:
\ns[i] = x	i -й элемент списка s заменяется на x
\ns[i:j:d] = t	Срез от i до j (с шагом d ) заменяется на (список) t
\ndel s[i:j:d]	Удаление элементов среза из последовательности
\n\nНекоторые методы для работы с последовательностями
\nНиже приведен ряд методов изменчивых последовательностей (например, списков).
\n.append(x)	Добавляет элемент в конец последовательности
\n.count(x)	Считает количество элементов, равных x
\n.extend(s)	Добавляет к концу последовательности последовательность s
\n.index(x)	Возвращает наименьшее i, такое, что s[i] == x. Возбуждает исключение ValueError, если x не найден в s
\n.insert(i, x)	Вставляет элемент x в i -й промежуток
\n.pop(i)	Возвращает i-й элемент, удаляя его из последовательности
\n.reverse(s)	Меняет порядок элементов s на обратный
\n.sort([cmpfunc])	Сортирует элементы s. Может быть указана своя функция сравнения cmpfunc
\n\nВзятие элемента по индексу и срезы
\nЗдесь же следует сказать несколько слов об индексировании последовательностей и выделении подстрок (и вообще - подпоследовательностей) по индексам. Для получения отдельного элемента последовательности используются квадратные скобки, в которых стоит выражение, дающее индекс. Индексы последовательностей в Python начинаются с нуля. Отрицательные индексы служат для отсчета элементов с конца последовательности ( -1 - последний элемент).
\nПримечание:
\nУдалять элементы можно только из изменчивых последовательностей и желательно не делать этого внутри цикла по последовательности.
\nНесколько интереснее обстоят дела со срезами. Дело в том, что в Python при взятии среза последовательности принято нумеровать не элементы, а промежутки между ними. Поначалу это кажется необычным, тем не менее, очень удобно для указания произвольных срезов. Перед нулевым (по индексу) элементом последовательности промежуток имеет номер 0, после него - 1 и т.д.. Отрицательные значения отсчитывают промежутки с конца строки. Для записи срезов используется следующий синтаксис:
\nпоследовательность[нач:кон:шаг]
\nгде нач - промежуток начала среза, кон - конца среза, шаг - шаг. По умолчанию нач=0, кон=len(последовательность), шаг=1, если шаг не указан, второе двоеточие можно опустить.
\nКак видно из этого примера, с помощью срезов удобно задавать любую подстроку, даже если она нулевой длины, как для удаления элементов, так и для вставки в строго определенное место.
\n\nТип dict
\nСловарь (хэш, ассоциативный массив) - это изменчивая структура данных для хранения пар ключ-значение, где значение однозначно определяется ключом. В качестве ключа может выступать неизменчивый тип данных (число, строка, кортеж и т.п.). Порядок пар ключ-значение произволен. Ниже приведен литерал для словаря и пример работы со словарем:
\n\nТип file
\nОбъекты этого типа предназначены для работы с внешними данными. В простом случае - это файл на диске. Файловые объекты должны поддерживать основные методы: read(), write(), readline(), readlines(), seek(), tell(), close() и т.п.
\nСледующий пример показывает копирование файла:
\nf1 = open(\"file1.txt\", \"r\")
\nf2 = open(\"file2.txt\", \"w\")
\nfor line in f1.readlines():
\n  f2.write(line)
\nf2.close()
\nf1.close()
\nСтоит заметить, что кроме собственно файлов в Python используются и файлоподобные объекты. В очень многих функциях просто неважно, передан ли ей объект типа file или другого типа, если он имеет все те же методы (и в том же смысле). Например, копирование содержимого по ссылке (URL) в файл file2.txt можно достигнуть, если заменить первую строку на
\nimport urllib
\nf1 = urllib.urlopen(\"http://python.onego.ru\")
\nО модулях, классах, объектах и функциях будет говориться на других лекциях.
\n\nВыражения
\nВ современных языках программирования принято производить большую часть обработки данных в выражениях. Синтаксис выражений у многих языков программирования примерно одинаков. Синтаксис выражений Python не удивит программиста чем-то новым. (Разве что цепочечные сравнения могут приятно порадовать.)
\nПриоритет операций показан ниже (в порядке увеличения). Для унарных операций x обозначает операнд. Ассоциативность операций в Python - слева-направо, за исключением операции возведения в степень ( ** ), которая ассоциативна справа налево.
\nlambda	лямбда-выражение
\nor	логическое ИЛИ
\nand	логическое И
\nnot x	логическое НЕ
\nin, not in	проверка принадлежности
\nis, is not	проверка идентичности
\n&lt;,&lt;=,>,>=,!=,==	сравнения
\n|	побитовое ИЛИ
\n^	побитовое исключающее ИЛИ
\n&amp;	побитовое И
\n&lt;&lt;, >>	побитовые сдвиги
\n+, -	сложение и вычитание
\n*, /, %	умножение, деление, остаток
\n+x, -x	унарный плюс и смена знака
\n~x	побитовое НЕ
\n**	возведение в степень
\nx.атрибут	ссылка на атрибут
\nx[индекс]	взятие элемента по индексу
\nx[от:до]	выделение среза (от и до)
\nf(аргумент,…)	вызов функции
\n( … )	скобки или кортеж
\n[ \.\.\. ]	список или списковое включение
\n{кл:зн, \.\.\.}	словарь пар ключ-значение
\n`выражения`	преобразование к строке (repr)
\nТаким образом, порядок вычислений операндов определяется такими правилами:
\n1.	Операнд слева вычисляется раньше операнда справа во всех бинарных операциях, кроме возведения в степень.
\n2.	Цепочка сравнений вида a &lt; b &lt; c \.\.\. y &lt; z фактически равносильна: (а &lt; b) and (b &lt; c) and \.\.\. and (y &lt; z).
\n3.	Перед фактическим выполнением операции вычисляются нужные для нее операнды. В большинстве бинарных операций предварительно вычисляются оба операнда (сначала левый), но операции or и and, а также цепочки сравнений вычисляют такое количество операндов, которое достаточно для получения результата. В невычисленной части выражения в таком случае могут даже быть неопределенные имена. Это важно учитывать, если используются функции с побочными эффектами.
\n4.	Аргументы функций, выражения для списков, кортежей, словарей и т.п. вычисляются слева-направо, в порядке следования в выражении.
\nВ случае неясности приоритетов желательно применять скобки. Несмотря на то, что одни и те же символы могут использоваться для разных операций, приоритеты операций не меняются. Так, % имеет тот же приоритет, что и *, а потому в следующем примере скобки просто необходимы, чтобы операция умножения произошла перед операцией форматирования:
\nprint \"%i\" % (i*j)
\nВыражения могут фигурировать во многих операторах Python и даже как самостоятельный оператор. У выражения всегда есть результат, хотя в некоторых случаях (когда выражение вычисляется ради побочных эффектов) этот результат может быть \"ничем\" - None.
\nОчень часто выражения стоят в правой части оператора присваивания или расширенного присваивания. В Python (в отличие, скажем, от C) нет операции присваивания, поэтому синтаксически перед знаком = могут стоять только идентификатор, индекс, срез, доступ к атрибуту или кортеж (список) из перечисленного. (Подробности в документации).
\n\nИмена
\nОб именах (идентификаторах) говорилось уже не раз, тем не менее, необходимо сказать несколько слов об их применении в языке Python.
\nИмя может начинаться с латинской буквы (любого регистра) или подчеркивания, а дальше допустимо использование цифр. В качестве идентификаторов нельзя применять ключевые слова языка и нежелательно переопределять встроенные имена.
\nИмена, начинающиеся с подчеркивания или двух подчеркиваний, имеют особый смысл. Одиночное подчеркивание говорит программисту о том, что имя имеет местное применение, и не должно использоваться за пределами модуля. Двойным подчеркиванием в начале и в конце обычно наделяются специальные имена атрибутов - об этом будет говориться в лекции по объектно-ориентированному программированию.
\nВ каждой точке программы интерпретатор \"видит\" три пространства имен: локальное, глобальное и встроенное. Пространство имен - отображение из имен в объекты.
\nДля понимания того, как Python находит значение некоторой переменной, необходимо ввести понятие блока кода. В Python блоком кода является то, что исполняется как единое целое, например, тело определения функции, класса или модуля.
\nЛокальные имена - имена, которым присвоено значение в данном блоке кода. Глобальные имена - имена, определяемые на уровне блока кода определения модуля или те, которые явно заданы в операторе global. Встроенные имена - имена из специального словаря __ builtins __.
\nОбласти видимости имен могут быть вложенными друг в друга, например, внутри вызванной функции видны имена, определенные в вызывающем коде. Переменные, которые используются в блоке кода, но связаны со значением вне кода, называются свободными переменными.
\nТак как переменную можно связать с объектом в любом месте блока, важно, чтобы это произошло до ее использования, иначе будет возбуждено исключение NameError. Связывание имен со значениями происходит в операторах присваивания, from, import, в формальных аргументах функций, при определении функции или класса, во втором параметре части except оператора try-except.
\nС областями видимости и связыванием имен есть много нюансов, которые хорошо описаны в документации. Желательно, чтобы программы не зависели от таких нюансов, а для этого достаточно придерживаться следующих правил:
\n1.	Всегда следует связывать переменную со значением (текстуально) до ее использования.
\n2.	Необходимо избегать глобальных переменных и передавать все в качестве параметров. Глобальными на уровне модуля должны остаться только имена-константы, имена классов и функций.
\n3.	Никогда не следует использовать from модуль import * - это может привести к затенению имен из других модулей, а внутри определения функции просто запрещено.
\nПредпочтительнее переделать код, нежели использовать глобальную переменную. Конечно, для программ, состоящих из одного модуля, это не так важно: ведь все определенные на уровне модуля переменные глобальны.
\nУбрать связь имени с объектом можно с помощью оператора del. В этом случае, если объект не имеет других ссылок на него, он будет удален. Для управления памятью в Python используется подсчет ссылок (reference counting), для удаления наборов объектов с зацикленными ссылками - сборка мусора (garbage collection).
</string>


    <string name="lesson3_text">
        Лекция 3: Основные стандартные модули Python\n\n
Понятие модуля
\nПеред тем как приступить к изучению модулей стандартной библиотеки, необходимо определить то, что в Python называется модулем.
\nВ соответствии с модульным подходом к программированию большая задача разбивается на несколько более мелких, каждую из которых (в идеале) решает отдельный модуль. В разных методологиях даются различные ограничения на размер модулей, однако при построении модульной структуры программы важнее составить такую композицию модулей, которая позволила бы свести к минимуму связи между ними. Набор классов и функций, имеющий множество связей между своими элементами, было бы логично расположить в одном модуле. Есть и еще одно полезное замечание: модули должно быть легче использовать, чем написать заново. Это значит, что модуль должен иметь удобный интерфейс: набор функций, классов и констант, который он предлагает своим пользователям.
\nВ языке Python набор модулей, посвященных одной проблеме, можно поместить в пакет. Хорошим примером такого пакета является пакет xml, в котором собраны модули для различных аспектов обработки XML.
\nВ программе на Python модуль представлен объектом-модулем, атрибутами которого являются имена, определенные в модуле:
\n>>> import datetime
\n>>> d1 = datetime.date(2004, 11, 20)
\nВ данном примере импортируется модуль datetime. В результате работы оператора import в текущем пространстве имен появляется объект с именем datetime.
\nМодули для использования в программах на языке Python по своему происхождению делятся на обычные (написанные на Python) и модули расширения, написанные на другом языке программирования (как правило, на C). С точки зрения пользователя они могут отличаться разве что быстродействием. Бывает, что в стандартной библиотеке есть два варианта модуля: на Python и на C. Таковы, например, модули pickle и cPickle. Обычно модули на Python в чем-то гибче, чем модули расширения.
\n\nМодули в Python
\nМодуль оформляется в виде отдельного файла с исходным кодом. Стандартные модули находятся в каталоге, где их может найти соответствующий интерпретатор языка. Пути к каталогам, в которых Python ищет модули, можно увидеть в значении переменной sys.path:
\nВ последних версиях Python модули можно помещать и в zip-архивы для более компактного хранения (по аналогии с jar-архивами в Java).
\nПри запуске программы поиск модулей также идет в текущем каталоге. (Нужно внимательно называть собственные модули, чтобы не было конфликта имен со стандартными или дополнительно установленными модулями.)
\nПодключение модуля к программе на Python осуществляется с помощью оператора import. У него есть две формы: import и from-import:
\nimport os
\nimport pre as re
\nfrom sys import argv, environ
\nfrom string import *
\nС помощью первой формы с текущей областью видимости связывается только имя, ссылающееся на объект модуля, а при использовании второй - указанные имена (или все имена, если применена * ) объектов модуля связываются с текущей областью видимости. При импорте можно изменить имя, с которым объект будет связан, с помощью as. В первом случае пространство имен модуля остается в отдельном имени и для доступа к конкретному имени из модуля нужно применять точку. Во втором случае имена используются так, как если бы они были определены в текущем модуле:
\nos.system(\"dir\")
\ndigits = re.compile(\"\\d+\")
\nprint argv[0], environ
\nПовторный импорт модуля происходит гораздо быстрее, так как модули кэшируются интерпретатором. Загруженный модуль можно загрузить еще раз (например, если модуль изменился на диске) с помощью функции reload():
\nimport mymodule
\n. . .
\nreload(mymodule)
\nОднако в этом случае все объекты, являющиеся экземплярами классов из старого варианта модуля, не изменят своего поведения.
\nПри работе с модулями есть и другие тонкости. Например, сам процесс импорта модуля можно переопределить. Подробнее об этом можно узнать в оригинальной документации.
\n\nВстроенные функции
\nВ среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. Для удобства функции условно разделены по категориям:
\n1.	Функции преобразования типов и классы: coerce, str, repr, int, list, tuple, long, float, complex, dict, super, file, bool, object
\n2.	Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode
\n3.	Функции обработки данных: apply, map, filter, reduce, zip, range, xrange, max, min, iter, enumerate, sum
\n4.	Функции определения свойств: hash, id, callable, issubclass, isinstance, type
\n5.	Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir
\n6.	Функции компиляции и исполнения: eval, execfile, reload, __import__, compile
\n7.	Функции ввода-вывода: input, raw_input, open
\n8.	Функции для работы с атрибутами: getattr, setattr, delattr, hasattr
\n9.	Функции-\"украшатели\" методов классов: staticmethod, classmethod, property
\n10.	Прочие функции: buffer, slice\n
\n\nФункции преобразования типов и классы
\nФункции и классы из этой категории служат для преобразования типов данных. В старых версиях Python для преобразования к нужному типу использовалась одноименная функция. В новых версиях Python роль таких функций играют имена встроенных классов (однако семантика не изменилась). Для понимания сути достаточно небольшого примера:
\n\nЧисловые и строковые функции
\nФункции работают с числовыми или строковыми аргументами. Ниже даны описания этих функций.
\nabs(x)	Модуль числа x. Результат: |x|.
\ndivmod(x, y)	Частное и остаток от деления. Результат: (частное, остаток).
\npow(x, y[, m])	Возведение x в степень y по модулю m. Результат: x**y % m.
\nround(n[, z])	Округление чисел до заданного знака после (или до) точки.
\nord(s)	Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке.
\nchr(n)	Возвращает строку с символом с заданным кодом.
\nlen(s)	Возвращает число элементов последовательности или отображения.
\noct(n), hex(n)	Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n.
\ncmp(x, y)	Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата сравнения.
\nunichr(n)	Возвращает односимвольную Unicode-строку с символом с кодом n.
\nunicode(s [, encoding[, errors]])	Создает Unicode-объект, соответствующий строке s в заданной кодировке encoding. Ошибки кодирования обрабатываются в соответствии с errors, который может принимать значения: \'strict\' (строгое преобразование), \'replace\' (с заменой несуществующих символов) или \'ignore\' (игнорировать несуществующие символы). По умолчанию: encoding=\'utf-8\', errors=\'strict\'.
\n\nФункции обработки данных
\nЭти функции подробнее будут рассмотрены в лекции по функциональному программированию. Пример с функциями range() и enumerate():
\n\nФункции определения свойств
\nЭти функции обеспечивают доступ к некоторым встроенным атрибутам объектов и другим свойствам. Следующий пример показывает некоторые из этих функций:
\n>>> s = \"abcde\"
\n>>> s1 = \"abcde\"
\n>>> s2 = \"ab\" + \"cde\"
\n>>> print \"hash:\", hash(s), hash(s1), hash(s2)
\nhash: -1332677140 -1332677140 -1332677140
\n>>> print \"id:\", id(s), id(s1), id(s2)
\nid: 1076618592 1076618592 1076618656
\nЗдесь, можно увидеть, что для одного и того же строкового литерала \"abcde\" получается один и тот же объект, тогда как для одинаковых по значению объектов вполне можно получить разные объекты.
\n\nФункции для доступа к внутренним структурам
\nВ современной реализации языка Python глобальные и локальные переменные доступны в виде словаря благодаря функциям globals() и locals(). Правда, записывать что-либо в эти словари не рекомендуется.
\nФункция vars() возвращает таблицу локальных имен некоторого объекта (если параметр не задан, она возвращает то же, что и locals() ). Обычно используется в качестве словаря для операции форматирования:
\na = 1
\nb = 2
\nc = 3
\nprint \"%(a)s + %(b)s = %©s\" % vars()
\n\nФункции компиляции и исполнения
\nФункция reload() уже рассматривалась, а из остальных функций этой категории особого внимания заслуживает eval(). Как следует из названия, эта функция вычисляет переданное ей выражение. В примере ниже вычисляется выражение, которое строится динамически:
\na = 2
\nb = 3
\nfor op in \\"+-*/%\":
\n  e = \"a \" + op + " b"
\n  print e, \"->\", eval(e)
\nУ функции eval() кроме подлежащего вычислению выражения есть еще два параметра - с их помощью можно задать глобальное и локальное пространства имен, из которых будут разрешаться имена выражения. Пример выше, переписанный для использования с собственным словарем имен в качестве глобального пространства имен:
\nfor op in \"+-*/%\":
\n  e = \"a \" + op + \" b\"
\n  print e, \"->\", eval(e, {\'a\': 2, \'b\': 3})
\nФункцией eval() легко злоупотребить. Нужно стараться использовать ее только тогда, когда без нее не обойтись. Из соображений безопасности не следует применять eval() для аргумента, в котором присутствует непроверенный ввод от пользователя.
\n\nФункции ввода-вывода
\nФункции input() и raw_input() используются для ввода со стандартного ввода. В серьезных программах их лучше не применять. Функция open() служит для открытия файла по имени для чтения, записи или изменения. В следующем примере файл открывается для чтения:
\n\nФункции для работы с атрибутами
\nУ объектов в языке Python могут быть атрибуты (в терминологии языка C++ - члены-данные и члены-функции).
\n\nФункции-\"украшатели\" методов классов
\nЭти функции будут рассмотрены в лекции, посвященной ООП.
\n\nОбзор стандартной библиотеки
\nМодули стандартной библиотеки можно условно разбить на группы по тематике.
\n1.	Сервисы периода выполнения. Модули: sys, atexit, copy, traceback, math, cmath, random, time, calendar, datetime, sets, array, struct, itertools, locale, gettext.
\n2.	Поддержка цикла разработки. Модули: pdb, hotshot, profile, unittest, pydoc. Пакеты docutils, distutils.
\n3.	Взаимодействие с ОС (файлы, процессы). Модули: os, os.path, getopt, glob, popen2, shutil, select, signal, stat, tempfile.
\n4.	Обработка текстов. Модули: string, re, StringIO, codecs, difflib, mmap, sgmllib, htmllib, htmlentitydefs. Пакет xml.
\n5.	Многопоточные вычисления. Модули: threading, thread, Queue.
\n6.	Хранение данных. Архивация. Модули: pickle, shelve, anydbm, gdbm, gzip, zlib, zipfile, bz2, csv, tarfile.
\n7.	Платформо-зависимые модули. Для UNIX: commands, pwd, grp, fcntl, resource, termios, readline, rlcompleter. Для Windows: msvcrt, _winreg, winsound.
\n8.	Поддержка сети. Протоколы Интернет. Модули: cgi, Cookie, urllib, urlparse, httplib, smtplib, poplib, telnetlib, socket, asyncore. Примеры серверов: SocketServer, BaseHTTPServer, xmlrpclib, asynchat.
\n9.	Поддержка Internet. Форматы данных. Модули: quopri, uu, base64, binhex, binascii, rfc822, mimetools, MimeWriter, multifile, mailbox. Пакет email.
\n10.	Python о себе. Модули: parser, symbol, token, keyword, inspect, tokenize, pyclbr, py_compile, compileall, dis, compiler.
\n11.	Графический интерфейс. Модуль Tkinter.
\nПримечание:
\nОчень часто модули содержат один или несколько классов, с помощью которых создается объект нужного типа, а затем речь идет уже не об именах из модуля, а об атрибутах этого объекта. И наоборот, некоторые модули содержат лишь функции, достаточно общие для того, чтобы работать над произвольными объектами (либо достаточно большой категорией объектов).
\n\nСервисы периода выполнения
\nМодуль sys
\nМодуль sys содержит информацию о среде выполнения программы, об интерпретаторе Python. Далее будут представлены наиболее популярные объекты из этого модуля: остальное можно изучить по документации.
\nexit([c])	Выход из программы. Можно передать числовой код завершения: 0 в случае успешного завершения, другие числа при аварийном завершении программы.
\nargv	Список аргументов командной строки. Обычно sys.argv[0] содержит имя запущенной программы, а остальные параметры передаются из командной строки.
\nplatform	Платформа, на которой работает интерпретатор.
\nstdin, stdout, stderr	Стандартный ввод, вывод, вывод ошибок. Открытые файловые объекты.
\nversion	Версия интерпретатора.
\nsetrecursionlimit(limit)	Установка уровня максимальной вложенности рекурсивных вызовов.
\nexc_info()	Информация об обрабатываемом исключении.
\n\nМодуль copy
\nЭтот модуль содержит функции для копирования объектов. Вначале предлагается к рассмотрению "парадокс", который вводит в замешательство новичков в Python:
\n\nМодули math и cmath
\nВ этих модулях собраны математические функции для действительных и комплексных аргументов. Это те же функции, что используются в языке C. Ниже даны функции модуля math. Там, где аргумент обозначен буквой z, аналогичная функция определена и в модуле cmath.
\n\nМодуль random
\nЭтот модуль генерирует псевдослучайные числа для нескольких различных распределений. Наиболее используемые функции:
\nrandom()	Генерирует псевдослучайное число из полуоткрытого диапазона [0.0, 1.0).
\nchoice(s)	Выбирает случайный элемент из последовательности s.
\nshuffle(s)	Размешивает элементы изменчивой последовательности s на месте.
\nrandrange([start,] stop[, step])	Выдает случайное целое число из диапазона range(start, stop, step). Аналогично choice(range(start, stop, step) ).
\nnormalvariate(mu, sigma)	Выдает число из последовательности нормально распределенных псевдослучайных чисел. Здесь mu - среднее, sigma - среднеквадратическое отклонение (sigma > 0)
\nОстальные функции и их параметры можно уточнить по документации. Следует отметить, что в модуле есть функция seed(n), которая позволяет установить генератор случайных чисел в некоторое состояние. Например, если возникнет необходимость многократного использования одной и той же последовательности псевдослучайных чисел.
\n\nМодуль time
\nЭтот модуль дает функции для получения текущего времени и преобразования форматов времени.
\n\nМодуль sets
\nМодуль реализует тип данных для множеств. Следующий пример показывает, как использовать этот модуль. Следует заметить, что в Python 2.4 и старше тип set стал встроенным, и вместо sets.Set можно использовать set:
\nМодули array и struct
\nЭти модули реализуют низкоуровневый массив и структуру данных. Основное их назначение - разбор двоичных форматов данных.
\n\nМодуль itertools
\nЭтот модуль содержит набор функций для работы с итераторами. Итераторы позволяют работать с данными последовательно, как если бы они получались в цикле. Альтернативный подход - использование списков для хранения промежуточных результатов - требует подчас большого количества памяти, тогда как использование итераторов позволяет получать значения на момент, когда они действительно требуются для дальнейших вычислений. Итераторы будут рассмотрены более подробно в лекции по функциональному программированию.
\n\nМодуль locale
\nМодуль locale применяется для работы с культурной средой. В конкретной культурной среде могут использоваться свои правила для написания чисел, валют, времени и даты и т.п.
\n\nМодуль gettext
\nПри интернационализации программы важно не только предусмотреть возможность использования нескольких культурных сред, но и перевод сообщений и меню программы на соответствующий язык. Модуль gettext позволяет упростить этот процесс достаточно стандартным способом. Основные сообщения программы пишутся на английском языке. А переводы строк, отмеченных в программе специальным образом, даются в виде отдельных файлов, по одному на каждый язык (или культурную среду). Уточнить нюансы использования gettext можно по документации к Python.
</string>


    <string name="lesson4_text">Лекция 4: Элементы функционального программирования\n\n
Что такое функциональное программирование?
\nФункциональное программирование - это стиль программирования, использующий только композиции функций. Другими словами, это программирование в выражениях, а не в императивных командах.
\nКак отмечает Дэвид Мертц (David Mertz) в своей статье о функциональном программировании на Python, \"функциональное программирование - программирование на функциональных языках (LISP, ML, OCAML, Haskell, …)\", основными атрибутами которых являются:
\n•	\"Наличие функций первого класса\" (функции наравне с другими объектами можно передавать внутрь функций).
\n•	Рекурсия является основной управляющей структурой в программе.
\n•	Обработка списков (последовательностей).
\n•	Запрещение побочных эффектов у функций, что в первую очередь означает отсутствие присваивания (в \"чистых\" функциональных языках)
\n•	Запрещение операторов, основной упор делается на выражения. Вместо операторов вся программа в идеале - одно выражение с сопутствующими определениями.
\n•	Ключевой вопрос: что нужно вычислить, а не как.
\n•	Использование функций более высоких порядков (функции над функциями над функциями).
\n\nФункциональная программа
\nВ математике функция отображает объекты из одного множества ( множества определения функции ) в другое ( множество значений функции ). Математические функции (их называют чистыми ) \"механически\", однозначно вычисляют результат по заданным аргументам. Чистые функции не должны хранить в себе какие-либо данные между двумя вызовами. Их можно представлять себе черными ящиками, о которых известно только то, что они делают, но совсем не важно, как.
\nПрограммы в функциональном стиле конструируются как композиция функций. При этом функции понимаются почти так же, как и в математике: они отображают одни объекты в другие. В программировании \"чистые\" функции - идеал, не всегда достижимый на практике. Практически полезные функции обычно имеют побочный эффект: сохраняют состояние между вызовами или меняют состояние других объектов. Например, без побочных эффектов невозможно представить себе функции ввода-вывода. Собственно, такие функции ради этих \"эффектов\" и используются. Кроме того, математические функции легко работают с объектами, требующими бесконечного объема информации (например, вещественные числа). В общем случае компьютерная программа может выполнить лишь приближенные вычисления.
\nКстати, бинарные операции \" + \", \" - \", \" * \", \" / \", которые записываются в выражениях, являются \"математическими\" функциями над двумя аргументами — операндами. Их используют настолько часто, что синтаксис языка программирования имеет для них более короткую запись. Модуль operator позволяет представлять эти операции в функциональном стиле:
\n>>> from operator import add, mul
\n>>> print add(2, mul(3, 4))
\n14
\n\nФункция: определение и вызов
\nКак уже говорилось, определить функцию в Python можно двумя способами: с помощью оператора def и lambda-выражения. Первый способ позволяет использовать операторы. При втором - определение функции может быть только выражением.
\nЗабегая вперед, можно заметить, что методы классов определяются так же, как и функции. Отличие состоит в специальном смысле первого аргумента self (в нем передается экземпляр класса).
\nЛучше всего рассмотреть синтаксис определения функции на нескольких примерах. После определения соответствующей функции показан один или несколько вариантов ее вызова (некоторые примеры взяты из стандартной библиотеки).
\nОпределение функции должно содержать список формальных параметров и тело определения функции. В случае с оператором def функции также задается некоторое имя. Формальные параметры являются локальными именами внутри тела определения функции, а при вызове функции они оказываются связанными с объектами, переданными как фактические параметры. Значения по умолчанию вычисляются в момент выполнения оператора def, и потому в них можно использовать видимые на момент определения имена.
\nВызов функции синтаксически выглядит как объект-функция(фактические параметры). Обычно объект-функция - это просто имя функции, хотя это может быть и любое выражение, которое в результате вычисления дает исполняемый объект.
\nФункция одного аргумента:
\ndef swapcase(s):
\n    return s.swapcase()
\n
\nprint swapcase(\"ABC\")
\nФункция двух аргументов, один из которых необязателен и имеет значение по умолчанию:
\ndef inc(n, delta=1):
\n    return n+delta
\n
\nprint inc(12)
\nprint inc(12, 2)
\nФункция с одним обязательным аргументом, с одним, имеющим значение по умолчанию и неопределенным числом именованных аргументов:
\ndef wrap(text, width=70, **kwargs):
\n   from textwrap import TextWrapper
\n   # kwargs  - словарь с именами и значениями аргументов
\n   w = TextWrapper(width=width, **kwargs)
\n   return w.wrap(text)
\n
\nprint wrap(\"my long text …\", width=4)
\nФункция произвольного числа аргументов:
\ndef max_min(*args):
\n  # args - список аргументов в порядке их указания при вызове
\n  return max(args), min(args)
\n
\nprint max_min(1, 2, -1, 5, 3)
\nВ языке Python функция может возвратить только одно значение, которое может быть кортежем. В следующем примере видно, как стандартная функция divmod() возвращает частное и остаток от деления двух чисел:
\ndef bin(n):
\n    \"\"\"Цифры двоичного представления натурального числа \"\"\"
\n    digits = []
\n    while n > 0:
\n        n, d = divmod(n, 2)
\n        digits = [d] + digits
\n    return digits
\n
\nprint bin(69)
\nПримечание:
\nВажно понять, что за именем функции стоит объект. Этот объект можно связать с другим именем:
\ndef add(x, y):
\n  return x + y
\naddition = add  # теперь addition и add - разные имена одного и того же объекта
\nПример, в котором в качестве значения по умолчанию аргумента функции используется изменчивый объект (список). Этот объект - один и тот же для всех вызовов функций, что может привести к казусам:
\ndef mylist(val, lst=[]):
\n  lst.append(val)
\n  return lst
\n
\nprint mylist(1),
\nprint mylist(2)
\nВместо ожидаемого [1] [2] получается [1] [1, 2], так как добавляются элементы к \"значению по умолчанию\".
\nПравильный вариант решения будет, например, таким:
\ndef mylist(val, lst=None):
\n  lst = lst or []
\n  lst.append(val)
\n  return lst
\nКонечно, приведенная выше форма может использоваться для хранения в функции некоторого состояния между ее вызовами, однако, практически всегда вместо функции с таким побочным эффектом лучше написать класс и использовать его экземпляр.
\n\nРекурсия
\nВ некоторых случаях описание функции элегантнее всего выглядит с применением вызова этой же функции. Такой прием, когда функция вызывает саму себя, называется рекурсией. В функциональных языках рекурсия обычно используется много чаще, чем итерация (циклы).
\nВ следующем примере переписывается функция bin() в рекурсивном варианте:
\ndef bin(n):
\n    \"\"\"Цифры двоичного представления натурального числа \"\"\"
\n    if n == 0:
\n      return []
\n    n, d = divmod(n, 2)
\n    return bin(n) + [d]
\n
\nprint bin(69)
\nЗдесь видно, что цикл while больше не используется, а вместо него появилось условие окончания рекурсии: условие, при выполнении которого функция не вызывает себя.
\nКонечно, в погоне за красивым рекурсивным решением не следует упускать из виду эффективность реализации. В частности, пример реализации функции для вычисления n -го числа Фибоначчи это демонстрирует:
\ndef Fib(n):
\n   if n &lt; 2:
\n       return n
\n   else:
\n       return Fib(n-1) + Fib(n-2)
\nВ данном случае количество рекурсивных вызовов растет экспоненциально от числа n, что совсем не соответствует временной сложности решаемой задачи.
\nВ качестве упражнения предлагается написать итеративный и рекурсивный варианты этой функции, которые бы требовали линейного времени для вычисления результата.
\n\nПредупреждение:
\nПри работе с рекурсивными функциями можно легко превысить глубину допустимой в Python рекурсии. Для настройки глубины рекурсии следует использовать функцию setrecursionlimit(N) из модуля sys, установив требуемое значение N.
\n\nФункции как параметры и результат
\nКак уже не раз говорилось, функции являются такими же объектами Python как числа, строки или списки. Это означает, что их можно передавать в качестве параметров функций или возвращать из функций.
\nФункции, принимающие в качестве аргументов или возвращающие другие функции в результате, называют функциями высшего порядка. В Python функции высшего порядка применяются программистами достаточно часто. В большинстве случаев таким образом строится механизм обратных вызовов (callbacks), но встречаются и другие варианты. Например, алгоритм поиска может вызывать переданную ему функцию для каждого найденного объекта.
\n\nФункция apply()
\nФункция apply() применяет функцию, переданную в качестве первого аргумента, к параметрам, которые переданы вторым и третьим аргументом. Эта функция в Python устарела, так как вызвать функцию можно с помощью обычного синтаксиса вызова функции. Позиционные и именованные параметры можно передать с использованием звездочек
\n\nОбработка последовательностей
\nМногие алгоритмы сводятся к обработке массивов данных и получению новых массивов данных в результате. Среди встроенных функций Python есть несколько для работы с последовательностями.
\nПод последовательностью в Python понимается любой тип данных, который поддерживает интерфейс последовательности (это несколько специальных методов, реализующих операции над последовательностями, которые в данном курсе обсуждаться не будут).
\nСледует заметить, что тип, основной задачей которого является хранение, манипулирование и обеспечение доступа к самостоятельным данным называется контейнерным типом или просто контейнером. Примеры контейнеров в Python - списки, кортежи, словари.
\n\nФункции range() и xrange()
\nФункция range() уже упоминалась при рассмотрении цикла for. Эта функция принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 (включительно) до заданного числа (исключительно). Если аргументов два, то список начинается с числа, указанного первым аргументом. Если аргументов три - третий аргумент задает шаг
\nФункция xrange() - аналог range(), более предпочтительный для использования при последовательном доступе, например, в цикле for или с итераторами. Она возвращает специальный xrange -объект, который ведет себя почти как список, порождаемый range(), но не хранит в памяти все выдаваемые элементы.
\n\nФункция map()
\nДля применения некоторой функции ко всем элементам последовательности применяется функция map(f, *args). Первый параметр этой функции - функция, которая будет применяться ко всем элементам последовательности. Каждый следующий n+1 -й параметр должен быть последовательностью, так как каждый его элемент будет использован в качестве n -го параметра при вызове функции f(). Результатом будет список, составленный из результатов выполнения этой функции.
\n\nФункция filter()
\nДругой часто встречающейся операцией является фильтрование исходной последовательности в соответствии с некоторым предикатом (условием). Функция filter(f, seq) принимает два аргумента: функцию с условием и последовательность, из которой берутся значения. В результирующую последовательность попадут только те значения из исходной, для которой f() возвратит истину. Если в качестве f задано значение None, результирующая последовательность будет состоять из тех значений исходной, которые имеют истинностное значение True.
\nНапример, в следующем фрагменте кода можно избавиться от символов, которые не являются буквами:
\n>>> filter(lambda x: x.isalpha(), \'Hi, there! I am eating an apple.\')
\n\'HithereIameatinganapple\'
\n\nСписковые включения
\nДля более естественной записи обработки списков в Python 2 была внесена новинка: списковые включения. Фактически это специальный сокращенный синтаксис для вложенных циклов for и условий if, на самом низком уровне которых определенное выражение добавляется к списку
\n\nФункция sum()
\nПолучить сумму элементов можно с помощью функции sum():
\n>>> sum(range(10))
\n45
\nЭта функция работает только для числовых типов, она не может конкатенировать строки. Для конкатенации списка строк следует использовать метод join().
\n\nФункция reduce()
\nДля организации цепочечных вычислений (вычислений с накоплением результата) можно применять функцию reduce(), которая принимает три аргумента: функцию двух аргументов, последовательность и начальное значение. С помощью этой функции можно, в частности, реализовать функцию sum():
\ndef sum(lst, start):
\n  return reduce(lambda x, y: x + y, lst, start)
\n
\n\nФункция zip()
\nЭта функция возвращает список кортежей, в котором i -й кортеж содержит i -е элементы аргументов-последовательностей. Длина результирующей последовательности равна длине самой короткой из последовательностей-аргументов:
\n>>> print zip(range(5), \"abcde\")
\n[(0, \'a\'), (1, \'b\'), (2, \'c\'), (3, \'d\'), (4, \'e\')]
\n\nИтераторы
\nПрименять для обработки данных явные последовательности не всегда эффективно, так как на хранение временных данных может тратиться много оперативной памяти. Более эффективным решением представляется использование итераторов - специальных объектов, обеспечивающих последовательный доступ к данным контейнера. Если в выражении есть операции с итераторами вместо контейнеров, промежуточные данные не будут требовать много места для хранения - ведь они запрашиваются по мере необходимости для вычислений. При обработке данных с использованием итераторов память будет требоваться только для исходных данных и результата, да и то необязательно вся сразу - ведь данные могут читаться и записываться в файл на диске.
\nИтераторы можно применять вместо последовательности в операторе for. Более того, внутренне оператор for запрашивает от последовательности ее итератор. Объект файлового типа тоже (построчный) итератор, что позволяет обрабатывать большие файлы, не считывая их целиком в память.
\nТам, где требуется итератор, можно использовать последовательность.
\nРабота с итераторами рассматривается в разделе, посвященном функциональному программированию, так как итераторами удобно манипулировать именно в функциональном стиле.
\nИспользовать итератор можно и \"вручную\". Любой объект, поддерживающий интерфейс итератора, имеет метод next(), который при каждом вызове выдает очередное значение итератора. Если больше значений нет, возбуждается исключение StopIteration. Для получения итератора по некоторому объекту необходимо прежде применить к этому объекту функцию iter() (цикл for делает это автоматически).
\nВ Python имеется модуль itertools, который содержит набор функций, комбинируя которые, можно составлять достаточно сложные схемы обработки данных с помощью итераторов. Далее рассматриваются некоторые функции этого модуля.
\n\nФункция iter()
\nЭта функция имеет два варианта использования. В первом она принимает всего один аргумент, который должен \"уметь\" предоставлять свой итератор. Во втором один из аргументов - функция без аргументов, другой - стоповое значение. Итератор вызывает указанную функцию до тех пор, пока та не возвратит стоповое значение. Второй вариант встречается много реже первого и обычно внутри метода класса, так как сложно порождать значения \"на пустом месте\"
\n\nФункция enumerate()
\nЭта функция создает итератор, нумерующий элементы другого итератора. Результирующий итератор выдает кортежи, в которых первый элемент - номер (начиная с нуля), а второй - элемент исходной последовательности:
\n>>> print [x for x in enumerate(\"abcd\")]
\n[(0, \'a\'), (1, \'b\'), (2, \'c\'), (3, \'d\')]
\n\nФункция sorted()
\nЭта функция, появившаяся в Python 2.4, позволяет создавать итератор, выполняющий сортировку:
\n>>> sorted(\'avdsdf\')
\n[\'a\', \'d\', \'d\', \'f\', \'s\', \'v\']
\nДалее рассматриваются функции модуля itertools.
\n\nФункция itertools.chain()
\nФункция chain() позволяет сделать итератор, состоящий из нескольких соединенных последовательно итераторов. Итераторы задаются в виде отдельных аргументов. Пример:
\nfrom itertools import chain
\nit1 = iter([1,2,3])
\nit2 = iter([8,9,0])
\nfor i in chain(it1, it2):
\n    print i,
\nдаст в результате
\n1 2 3 8 9 0
\n\nФункция itertools.repeat()
\nФункция repeat() строит итератор, повторяющий некоторый объект заданное количество раз:
\nfor i in itertools.repeat(1, 4):
\n    print i,
\n
\n1 1 1 1
\n\nФункция itertools.count()
\nБесконечный итератор, дающий целые числа, начиная с заданного:
\nfor i in itertools.count(1):
\n    print i,
\n    if i > 100:
\n        break
\n
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72
73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
96 97 98 99 100 101
\n\nФункция itertools.cycle()
\nМожно бесконечно повторять и некоторую последовательность (или значения другого итератора) с помощью функции cycle()
\n\nФункции itertools.imap(), itertools.starmap() и itertools.ifilter()
\nАналогами map() и filter() в модуле itertools являются imap() и ifilter(). Отличие imap() от map() в том, что вместо значения от преждевременно завершившихся итераторов объект None не подставляется.
\nЗдесь следует заметить, что обычная функция map() нормально воспринимает итераторы в любом сочетании с итерабельными (поддающимися итерациям) объектами
\nitertools.imap(), но имеет всего два аргумента. Второй аргумент - последовательность кортежей, каждый кортеж которой задает набор параметров для функции (первого аргумента
\nФункция ifilter() работает как filter(). Кроме того, в модуле itertools есть функция ifilterfalse(), которая как бы добавляет отрицание к значению функции
</string>


    <string name="lesson5_text">
    Лекция 5: Объектно-ориентированное программирование в языке Python\n\n
\nPython проектировался как объектно-ориентированный язык программирования. Это означает (по Алану Кэю, автору объектно-ориентированного языка Smalltalk), что он построен с учетом следующих принципов:
\n1.	Все данные в нем представляются объектами.
\n2.	Программу можно составить как набор взаимодействующих объектов, посылающих друг другу сообщения.
\n3.	Каждый объект имеет собственную часть памяти и может состоять из других объектов.
\n4.	Каждый объект имеет тип.
\n5.	Все объекты одного типа могут принимать одни и те же сообщения (и выполнять одни и те же действия).
\n\nПримечание:
\nК сожалению, большинство введений в ООП (даже именитых авторов) изобилует значительным числом терминов, зачастую затемняющих суть вопроса. В данном изложении будут употребляться только те термины, которые необходимы на практике для взаимопонимания разработчиков или для расширения кругозора. Так как в разных языках программирования ООП имеет свои нюансы, в скобках иногда будут даваться синонимы или аналоги того или иного термина.
\n\nПримечание:
\nОО программирование - это методология написания кода. Здесь не будет подробно рассматриваться объектно-ориентированный анализ и объектно-ориентированное проектирование, которые не менее важны как стадии создания программного обеспечения.
\n\nОсновные понятия
\nПри процедурном программировании программа разбивается на части в соответствии с алгоритмом: каждая часть ( подпрограмма, функция, процедура ) является составной частью алгоритма.
\nПри объектно-ориентированном программировании программа строится как совокупность взаимодействующих объектов.
\nС точки зрения объектно-ориентированного подхода, объект - это нечто, обладающее значением (состоянием), типом (поведением) и индивидуальностью. Когда программист выделяет объекты в предметной области, он обычно абстрагируется (отвлекается) от большинства их свойств, концентрируясь на существенных для задачи свойствах. Над объектами можно производить операции (посылая им сообщения). В языке Python все данные представлены в виде объектов.
\nВзаимодействие объектов заключается в вызове методов одних объектов другими. Иногда говорят, что объекты посылают друг другу сообщения. Сообщения - это запросы к объекту выполнить некоторые действия. ( Сообщения, методы, операции, функции-члены являются синонимами).
\nКаждый объект хранит свое состояние (для этого у него есть атрибуты ) и имеет определенный набор методов. (Синонимы: атрибут, поле, слот, объект-член, переменная экземпляра ). Методы определяют поведение объекта. Объекты класса имеют общее поведение.
\nОбъекты описываются не индивидуально, а с помощью классов. Класс - объект, являющийся шаблоном объекта. Объект, созданный на основе некоторого класса, называется экземпляром класса. Все объекты определенных пользователем классов являются экземплярами класса. Тем не менее, объекты даже с одним и тем же состоянием могут быть разными объектами. Говорят, что они имеют разную индивидуальность.
\nВ языке Python для определения класса используется оператор class:
\nclass имя_класса(класс1, класс2, …):
\n  # определения методов
\nКласс определяет тип объекта, то есть его возможные состояния и набор операций.
\n\nАбстракция и декомпозиция
\nАбстракция в ООП позволяет составить из данных и алгоритмов обработки этих данных объекты, отвлекаясь от несущественных (на некотором уровне) с точки зрения составленной информационной модели деталей. Таким образом, программа подвергается декомпозиции на части \"дозированной\" сложности. Отдельный объект, даже вместе с совокупностью его связей с другими объектами, человеком воспринимается легче (именно так он привык оперировать в реальном мире), чем что-то неструктурированное и монотонное.
\nПеред тем как начать написание даже самой простенькой объектно-ориентированной программы, необходимо провести анализ предметной области, для того чтобы выявить в ней классы объектов.
\nПри выделении объектов необходимо абстрагироваться (отвлечься) от большинства присущих им свойств и сконцентрироваться на свойствах, значимых для задачи..
\nВыделяемые объекты необязательно должны походить на физические объекты - ведь это абстракции, за которыми скрываются процессы, взаимодействия, отношения.
\nУдачная декомпозиция стоит многого. От нее зависят не только количественные характеристики кода (быстродействие, занимаемая память), но и трудоемкость дальнейшего развития и сопровождения. При отсутствии соответствующего опыта лучше не загадывать будущих путей развития программы, а делать ее как можно проще, под конкретную задачу.
\nДаже если просто перечислить все существительные, встретившиеся в описании задачи (явно или неявно), получится неплохой список кандидатов в классы.
\nПри процедурном подходе тоже используется декомпозиция, но при объектно-ориентированном подходе производится декомпозиция не самого алгоритма на более мелкие части, а предметной области на классы объектов.
\n\nОбъекты
\nДо этой лекции объекты Python встречались много раз: ведь каждое число, строка, функция, модуль и т.п. - это объекты. Некоторые встроенные объекты имеют в Python синтаксическую поддержку (для задания литералов). Таковы числа, строки, списки, кортежи и некоторые другие типы.
\nТеперь следует посмотреть на них в свете только что приведенных определений. Пример:
\na = 3
\nb = 4.0
\nc = a + b
\nЗдесь происходит следующее. Сначала имя \" a \" связывается в локальном пространстве имен с объектом-числом 3 (целое число). Затем \" b \" связывается с объектом-числом 4.0 (число с плавающей точкой). После этого над объектами 3 и 4.0 выполняется операция сложения, и имя \" c \" связывается с получившимся объектом. Кстати, операциями, в основном, будут называться методы, которые имеют в Python синтаксическую поддержку, в данном случае - инфиксную запись. То же самое можно записать как:
\nc = a.__add__(b)
\nЗдесь __add__() - метод объекта a, который реализует операцию + между этим объектом и другим объектом.
\nУзнать набор методов некоторого объекта можно с помощью встроенной функции dir()
\nЗдесь стоит указать на еще одну особенность Python. Не только инфиксные операции, но и встроенные функции ожидают наличия некоторых методов у объекта. Например, можно записать:
\nabs©
\nА функция abs() на самом деле использует метод переданного ей объекта:
\nc.__abs__()
\nОбъекты появляются в результате вызова функций-фабрик или конструкторов классов (об этом ниже), а заканчивают свое существование при удалении последней ссылки на объект. Оператор del удаляет имя (а значит, и одну ссылку на объект) из пространства имен:
\na = 1
\n# …
\ndel a
\n# имени a больше нет
\n\nТипы и классы
\nТип определяет область допустимых значений объекта и набор операций над ним. В ООП тип тесно связан с поведением - действиями объекта, состоящими в изменении внутреннего состояния и вызовами методов других объектов.
\nРанее в языке Python встроенные типы данных не являлись экземплярами класса, поэтому считалось, что это были просто объекты определенного типа. Теперь ситуация изменилась, и объекты встроенных типов имеют классы, к которым они принадлежат. Таким образом, тип и класс в Python становятся синонимами.
\nИнтерпретатор языка Python всегда может сказать, к какому типу относится объект. Однако с точки зрения применимости объекта в операции его принадлежность к классу не играет решающей роли: гораздо важнее, какие методы поддерживает объект.
\nПримечание:
\nПока что в Python есть \"классические\" и \"новые\" классы. Первые классы определяются сами по себе, а вторые обязательно ведут свою родословную от класса object. Для целей данного изложения разница между этими видами классов не имеет значения.
\nЭкземпляры классов могут появляться в программе не только из литералов или в результате операций. Обычно для получения объекта класса достаточно вызвать конструктор этого класса с некоторыми параметрами. Объект-класс, как и объект-функция, может быть вызван. Это и будет вызовом конструктора:
\n>>> import sets
\n>>> s = sets.Set([1, 2, 3])
\nВ этом примере модуль sets содержит определение класса Set. Вызывается конструктор этого класса с параметром [1, 2, 3]. В результате с именем s будет связан объект-множество из трех элементов 1, 2, 3.
\nСледует заметить, что, кроме конструктора, определенные классы имеют и деструктор - метод, который вызывается при уничтожении объекта. В языке Python объект уничтожается в случае удаления последней ссылки на него либо в результате сборки мусора, если объект оказался в неиспользуемом цикле ссылок. Так как Python сам управляет распределением памяти, деструкторы в нем нужны очень редко. Обычно в том случае, когда объект управляет ресурсом, который нужно корректно вернуть в определенное состояние.
\nЕще один способ получить объект некоторого типа - использование функций-фабрик. По синтаксису вызов функции-фабрики не отличается от вызова конструктора класса.
\n\nОпределение класса
\nПусть в ходе анализа данной предметной области необходимо определить класс Граф. Граф - это множество вершин и набор ребер, попарно соединяющий эти вершины. Над графом можно проделывать операции, такие как добавление вершины, ребра, проверка наличия ребра в графе и т.п. На языке Python определение класса может выглядеть так:
\nПринадлежность классу можно выяснить с помощью встроенной функции isinstance():
\nprint isinstance(g, G)
\n\nИнкапсуляция
\nОбычно считается, что без инкапсуляции невозможно представить себе ООП, что это ключевое понятие. История развития методологий программирования движима борьбой со сложностью разработки программного обеспечения. Сложность больших программных систем, в создании которых участвует сразу большое количество разработчиков, уменьшается, если на верхнем уровне не видно деталей реализации нижних уровней. Собственно, процедурный подход был первым шагом на этом пути. Под инкапсуляцией (encapsulation, что можно перевести по-разному, но на нужные ассоциации хорошо наводит слово \"обволакивание\") понимается сокрытие информации о внутреннем устройстве объекта, при котором работа с объектом может вестись только через его общедоступный (public) интерфейс. Таким образом, другие объекты не должны вмешиваться в \"дела\" объекта, кроме как используя вызовы методов.
\nВ языке Python инкапсуляции не придается принципиального значения: ее соблюдение зависит от дисциплинированности программиста. В других языках программирования имеются определенные градации доступности методов объекта.
\n\nДоступ к свойствам
\nВ языке Python не считается зазорным получить доступ к некоторому атрибуту (не методу) напрямую, если, конечно, этот атрибут описан в документации как часть интерфейса класса. Такие атрибуты называются свойствами (properties). В других языках программирования принято для доступа к свойствам создавать специальные методы (вместо того чтобы напрямую обращаться к общедоступным членам-данным). В Python достаточно использовать ссылку на атрибут, если свойство ни на что в объекте не влияет (то есть другие объекты могут его произвольно менять).
\nА на самом деле будут вызываться соответствующие методы: setx(), getx(), delx().
\nСледует отметить, что в экземпляре класса в Python можно организовать доступ к любым (даже несуществующим) атрибутам, обрабатывая запрос на доступ к атрибуту группой специальных методов:
\n__getattr__(self, name)	Этот метод объекта вызывается в том случае, если атрибут не найден другим способом (его нет в данном экземпляре или в дереве классов). Здесь name - имя атрибута. Метод должен вычислить значение атрибута либо возбудить исключение AttributeError. Для получения полного контроля над атрибутами в \"новых\" классах (то есть потомках object ) используйте метод __getattribute__().
\n__setattr__(self, name, value)	Этот метод вызывается при присваивании значения некоторому атрибуту. В отличие от __getattr__(), метод всегда вызывается, а не только тогда, когда атрибут может быть найден в экземпляре класса, поэтому нужно с осторожностью присваивать значения атрибутам внутри этого метода: это может вызвать рекурсию. Для присваивания значений атрибутов предпочтительнее присваивать словарю __dict__: self.__dict__[name] = value или (для \"новых\" классов) - обращение к __setattr__() базового класса: object.__setattr__(self, name, value).
\n__delattr__(self, name)	Как можно догадаться из названия, этот метод служит для удаления атрибута.
\n\nСокрытие данных
\nПодчеркивание (\" _ \") в начале имени атрибута указывает на то, что он не входит в общедоступный интерфейс. Обычно применяется одиночное подчеркивание, которое в языке не играет особой роли, но как бы говорит программисту: \"этот метод только для внутреннего использования\". Двойное подчеркивание работает как указание на то, что атрибут - приватный.
\n\nПолиморфизм
\nВ переводе с греческого полиморфизм означает \"многоформие\". Так в информатике называют возможность использования одного имени для выполнения различных действий.
\nМожно встретить множество определений полиморфизма (также есть несколько видов полиморфизма) в зависимости от языка программирования. Как правило, в качестве примера проявления полиморфизма приводят переопределение методов в подклассах. При этом можно создать функцию, требующую формального аргумента - экземпляра базового класса, а в качестве фактического аргумента давать экземпляр подкласса. Функция будет вызывать метод объекта с именем, а за именем будут скрываться различные действия. В связи с этим полиморфизм обычно связывают с иерархией наследования.
\nВ Python полиморфизм связан не с наследованием, а с набором и смыслом доступных методов в экземпляре класса. Ниже будет показано, что, имея определенные методы, можно воссоздать класс для строки или любого другого встроенного типа. Для этого необходимо определить свойственный типу набор методов. Конечно, нужный набор методов можно получить и с помощью наследования, но в Python это не только не обязательно, но иногда и противоречит здравому смыслу.
\nПри написании функции в Python обычно не проверяется, к какому типу (классу) относится тот или иной аргумент: некоторые методы просто применяются к переданному объекту. Тем самым функции получаются максимально обобщенными: они не требуют от объектов-параметров большего, чем наличие методов с определенным именем, набором аргументов и семантикой.
\nСледующий пример показывает полиморфизм в том виде, в котором он свойственен Python:
\ndef get_last(x):
\n  return x[-1]
\n
\nprint get_last([1, 2, 3])
\nprint get_last(\"abcd\")
\nОписанной функции будет подходить в качестве аргумента все, от чего можно взять индекс -1 (последний элемент). Однако семантика \"взятие последнего элемента\" выполняется только для последовательностей. Функция будет работать и для словарей, но смысл при этом будет немного другой.
\n\nИмитация типов
\nДля иллюстрации понятия полиморфизма можно построить собственный тип, похожий на встроенный тип \"функция\".
\n\nОтношения между классами
\nНаследование
\nНа практике часто возникает ситуация, когда в предметной области выделены очень близкие, но вместе с тем неодинаковые классы. Одним из способов сокращения описания классов за счет использования их сходства является выстраивание классов в иерархию. В корне этой иерархии стоит базовый класс, от которого нижележащие классы иерархии наследуют свои атрибуты, уточняя и расширяя поведение вышележащего класса. Обычно принципом построения классификации является отношение \"IS-A\" (\"ЕСТЬ\"). Например, класс Окружность в программе - графическом редакторе может быть унаследован от класса Геометрическая Фигура. При этом Окружность будет являться подклассом (или субклассом) для класса Геометрическая Фигура, а Геометрическая Фигура - надклассом (или суперклассом) для класса Окружность.
\nВ основе построения классификации всегда стоит принцип, играющий наиболее важную роль в анализируемой и моделируемой системе. Следует заметить, что одним из \"перегибов\" при использовании ОО методологии является искусственное выстраивание иерархии классов. Например, не стоит наследовать класс Машина от класса Колесо (внимательные заметят, что здесь отношение другое: колесо является частью машины).
\nКласс называется абстрактным, если он предназначен только для наследования. Экземпляры абстрактного класса обычно не имеют большого смысла. Классы с рабочими экземплярами называются конкретными.
\nВ Python примером абстрактного класса является встроенный тип basestring, у которого есть конкретные подклассы str и unicode.
\n\nМножественное наследование
\nВ отличие, например, от Java, в языке Python можно наследовать класс от нескольких классов. Такая ситуация называется множественным наследованием (multiple inheritance).
\nКласс, получаемый при множественном наследовании, объединяет поведение своих надклассов, комбинируя стоящие за ними абстракции.
\nИспользовать множественное наследование следует очень осторожно, а необходимость в нем возникает реже одиночного.
\n•	Множественное наследование можно применить для получения класса с заданными общедоступными методами, причем методы задает один родительский класс, а реализуются они на основе методов второго класса. Первый класс может быть полностью абстрактным.
\n•	Множественное наследование применяется для добавления примесей (mixins). Примесь - специально сконструированный класс, добавляющий в некоторый класс какую-либо черту поведения (привнесением атрибутов). Примеси обычно являются абстрактными классами.
\n•	Изредка множественное наследование применяется в своем основном смысле, когда объекты класса, получающегося в результате множественного наследования, предназначаются для использования в качестве объектов всех родительских классов.
    </string>


    <string name="lesson6_text">Лекция 6: Численные алгоритмы. Матричные вычисления\n\n
Numeric Python
\nЭтот раздел в достаточной степени устарел. Сейчас модуль называется numpy. В целом, всё, что было в Numeric, доступно и в numpy, но имена могут не совпадать. Numeric доступен как numpy/oldnumeric. Рекомендуем обратиться к документации.
\n\nNumeric Python - это несколько модулей для вычислений с многомерными массивами, необходимых для многих численных приложений. Модуль Numeric вносит в Python возможности таких пакетов и систем как MatLab, Octave (аналог MatLab), APL, J, S+, IDL. Пользователи найдут Numeric достаточно простым и удобным. Стоит заметить, что некоторые синтаксические возможности Python (связанные с использованием срезов) были специально разработаны для Numeric.
\nNumeric Python имеет средства для:
\n•	матричных вычислений LinearAlgebra ;
\n•	быстрого преобразования Фурье FFT ;
\n•	работы с недостающими экспериментальными данными MA ;
\n•	статистического моделирования RNG ;
\n•	эмуляции базовых функций программы MatLab.
\n\nМодуль Numeric
\nМодуль Numeric определяет полноценный тип-массив и содержит большое число функций для операций с массивами. Массив - это набор однородных элементов, доступных по индексам. Массивы модуля Numeric могут быть многомерными, то есть иметь более одной размерности.
\n\nСnоздание массива
\nДля создания массива можно использовать функцию array() с указанием содержимого массива (в виде вложенных списков) и типа. Функция array() делает копию, если ее аргумент - массив. Функция asarray() работает аналогично, но не создает нового массива, когда ее аргумент уже является массивом:
\n>>> from Numeric import *
\n>>> print array([[1, 2], [3, 4], [5, 6]])
\n[[1 2]
\n [3 4]
\n [5 6]]
\n>>> print array([[1, 2, 3], [4, 5, 6]], float)
\n[[ 1.  2.  3.]
\n [ 4.  5.  6.]]
\n>>> print array([78, 85, 77, 69, 82, 73, 67], \'c\')
\n[N U M E R I C]
\nВ качестве элементов массива можно использовать следующие типы: Int8-Int32, UnsignedInt8-UnsignedInt32, Float8-Float64, Complex8-Complex64 и PyObject. Числа 8, 16, 32 и 64 показывают количество битов для хранения величины. Типы Int, UnsignedInteger, Float и Complex соответствуют наибольшим принятым на данной платформе значениям. В массиве можно также хранить ссылки на произвольные объекты.
\nКоличество размерностей и длина массива по каждой оси называются формой массива (shape). Доступ к форме массива реализуется через атрибут shape:
\n>>> from Numeric import *
\n>>> a = array(range(15), int)
\n>>> print a.shape
\n(15,)
\n>>> print a
\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
\n>>> a.shape = (3, 5)
\n>>> print a.shape
\n(3, 5)
\n>>> print a
\n[[ 0  1  2  3  4]
\n [ 5  6  7  8  9]
\n [10 11 12 13 14]]
\n\nМетоды массивов
\nПридать нужную форму массиву можно функцией Numeric.reshape(). Эта функция сразу создает объект-массив нужной формы из последовательности.
\n>>> import Numeric
\n>>> print Numeric.reshape(\"абракадабр\", (5, -1))
\n[[а б]
\n [р а]
\n [к а]
\n [д а]
\n [б р]]
\nВ этом примере -1 в указании формы говорит о том, что соответствующее значение можно вычислить. Общее количество элементов массива известно (10), поэтому длину вдоль одной из размерностей задавать не обязательно.
\nЧерез атрибут flat можно получить одномерное представление массива:
\n>>> a = array([[1, 2], [3, 4]])
\n>>> b = a.flat
\n>>> b
\narray([1, 2, 3, 4])
\n>>> b[0] = 9
\n>>> b
\narray([9, 2, 3, 4])
\n>>> a
\narray([[9, 2],
\n       [3, 4]])
\nСледует заметить, что это новый вид того же массива, поэтому присваивание значений его элементам приводит к изменениям в исходном массиве.
\nФункция Numeric.resize() похожа на Numeric.reshape, но может подстраивать число элементов:
\n>>> print Numeric.resize(\"NUMERIC\", (3, 2))
\n[[N U]
\n [M E]
\n [R I]]
\n>>> print Numeric.resize(\"NUMERIC\", (3, 4))
\n[[N U M E]
\n [R I C N]
\n [U M E R]]
\nФункция Numeric.zeros() порождает массив из одних нулей, а Numeric.ones() - из одних единиц. Единичную матрицу можно получить с помощью функции Numeric.identity(n):
\n>>> print Numeric.zeros((2,3))
\n[[0 0 0]
\n [0 0 0]]
\n>>> print Numeric.ones((2,3))
\n[[1 1 1]
\n [1 1 1]]
\n>>> print Numeric.identity(4)
\n[[1 0 0 0]
\n [0 1 0 0]
\n [0 0 1 0]
\n [0 0 0 1]]
\nДля копирования массивов можно использовать метод copy():
\n>>> import Numeric
\n>>> a = Numeric.arrayrange(9)
\n>>> a.shape = (3, 3)
\n>>> print a
\n[[0 1 2]
\n [3 4 5]
\n [6 7 8]]
\n>>> a1 = a.copy()
\n>>> a1[0, 1] = -1   # операция над копией
\n>>> print a1
\n[[0 -1 2]
\n [3 4 5]
\n [6 7 8]]
\nМассив можно превратить обратно в список с помощью метода tolist():
\n>>> a.tolist()
\n[[0, 1, 2], [3, 4, 5], [6, 7, 8]]
\n\nСрезы
\nОбъекты-массивы Numeric используют расширенный синтаксис выделения среза. Следующие примеры иллюстрируют различные варианты записи срезов. Функция Numeric.arrayrange() является аналогом range() для массивов.
\n>>> import Numeric
\n>>> a = Numeric.arrayrange(24) + 1
\n>>> a.shape = (4, 6)
\n>>> print a             # исходный массив
\n[[ 1  2  3  4  5  6]
\n [ 7  8  9 10 11 12]
\n [13 14 15 16 17 18]
\n [19 20 21 22 23 24]]
\n>>> print a[1,2]        # элемент 1,2
\n9
\n>>> print a[1,:]        # строка 1
\n[ 7  8  9 10 11 12]
\n>>> print a[1]          # тоже строка 1
\n[ 7  8  9 10 11 12]
\n>>> print a[:,1]        # столбец 1
\n[ 2  8 14 20]
\n>>> print a[-2,:]       # предпоследняя строка
\n[13 14 15 16 17 18]
\n>>> print a[0:2,1:3]    # окно 2x2
\n[[2 3]
\n [8 9]]
\n>>> print a[1,::3]      # каждый третий элемент строки 1
\n[ 7 10]
\n>>> print a[:,::-1]     # элементы строк в обратном порядке
\n[[ 6  5  4  3  2  1]
\n [12 11 10  9  8  7]
\n [18 17 16 15 14 13]
\n [24 23 22 21 20 19]]
\nСрез не копирует массив (как это имеет место со списками), а дает доступ к некоторой части массива. Далее в примере меняется на 0 каждый третий элемент строки 1:
\n>>> a[1,::3] = Numeric.array([0,0])
\n>>> print a
\n[[ 1  2  3  4  5  6]
\n [ 0  8  9  0 11 12]
\n [13 14 15 16 17 18]
\n [19 20 21 22 23 24]]
\nВ следующих примерах находит применение достаточно редкая синтаксическая конструкция: срез с многоточием ( Ellipsis ). Многоточие ставится для указания произвольного числа пропущенных размерностей ( :,:,…,:):
\n>>> import Numeric
\n>>> a = Numeric.arrayrange(24) + 1
\n>>> a.shape = (2,2,2,3)
\n>>> print a
\n[[[[ 1  2  3]
\n   [ 4  5  6]]
\n  [[ 7  8  9]
\n   [10 11 12]]]
\n [[[13 14 15]
\n   [16 17 18]]
\n  [[19 20 21]
\n   [22 23 24]]]]
\n>>> print a[0,…]          # 0-й блок
\n[[[ 1  2  3]
\n  [ 4  5  6]]
\n [[ 7  8  9]
\n  [10 11 12]]]
\n>>> print a[0,:,:,0]        # срез по первой и последней размерностям
\n[[ 1  4]
\n [ 7 10]]
\n>>> print a[0,…,0]        # то же, но с использованием многоточия
\n[[ 1  4]
\n [ 7 10]]
\n\nУниверсальные функции
\nМодуль Numeric определяет набор функций для применения к элементам массива. Функции применимы не только к массивам, но и к последовательностям (к сожалению, итераторы пока не поддерживаются). В результате получаются массивы.
\nadd(x, y), subtract(x, y)	Сложение и вычитание
\nmultiply(x, y), divide(x, y)	Умножение и деление
\nremainder(x, y), fmod(x, y)	Получение остатка от деления (для целых чисел и чисел с плавающей запятой)
\npower(x, y)	Возведение в степень
\nsqrt(x)	Извлечение корня квадратного
\nnegative(x), absolute(x), fabs(x)	Смена знака и абсолютное значение
\nceil(x), floor(x)	Наименьшее (наибольшее) целое, большее (меньшее) или равное аргументу
\nhypot(x, y)	Длина гипотенузы (даны длины двух катетов)
\nsin(x), cos(x), tan(x)	Тригонометрические функции
\narcsin(x), arccos(x), arctan(x)	Обратные тригонометрические функции
\narctan2(x, y)	Арктангенс от частного аргумента
\nsinh(x), cosh(x), tanh(x)	Гиперболические функции
\narcsinh(x), arccosh(x), arctanh(x)	Обратные гиперболические функции
\nexp(x)	Экспонента ( ex )
\nlog(x), log10(x)	Натуральный и десятичный логарифмы
\nmaximum(x, y), minimum(x, y)	Максимум и минимум
\nconjugate(x)	Сопряжение (для комплексных чисел)
\nequal(x, y), not_equal(x, y)	Равно, не равно
\ngreater(x, y), greater_equal(x, y)	Больше, больше или равно
\nless(x, y), less_equal(x, y)	Меньше, меньше или равно
\nlogical_and(x, y), logical_or(x, y)	Логические И, ИЛИ
\nlogical_xor(x, y)	Логическое исключающее ИЛИ
\nlogical_not(x)	Логические НЕ
\nbitwise_and(x, y), bitwise_or(x, y)	Побитовые И, ИЛИ
\nbitwise_xor(x, y)	Побитовое исключающее ИЛИ
\ninvert(x)	Побитовая инверсия
\nleft_shift(x, n), right_shift(x, n)	Побитовые сдвиги влево и вправо на n битов
\nПеречисленные функции являются объектами типа ufunc и применяются к массивам поэлементно. Эти функции имеют специальные методы:
\naccumulate()	Аккумулирование результата.
\nouter()	Внешнее \"произведение\".
\nreduce()	Сокращение.
\nreduceat()	Сокращение в заданных точках.
\nПример с функцией add() позволяет понять смысл универсальной функции и ее методов:
\n>>> from Numeric import add
\n>>> add([[1, 2], [3, 4]],  [[1, 0], [0, 1]])
\narray([[2, 2],
\n       [3, 5]])
\n>>> add([[1, 2], [3, 4]],  [1, 0])
\narray([[2, 2],
\n       [4, 4]])
\n>>> add([[1, 2], [3, 4]],  1)
\narray([[2, 3],
\n       [4, 5]])
\n>>> add.reduce([1, 2, 3, 4])                    # т.е. 1+2+3+4
\n10
\n>>> add.reduce([[1, 2], [3, 4]], 0)             # т.е. [1+3 2+4]
\narray([4, 6])
\n>>> add.reduce([[1, 2], [3, 4]], 1)             # т.е. [1+2 3+4]
\narray([3, 7])
\n>>> add.accumulate([1, 2, 3, 4])                # т.е. [1 1+2 1+2+3 1+2+3+4]
\narray([ 1,  3,  6, 10])
\n>>> add.reduceat(range(10), [0, 3, 6])          # т.е. [0+1+2 3+4+5 6+7+8+9]
\narray([ 3, 12, 30])
\n>>> add.outer([1,2], [3,4])                     # т.е. [[1+3 1+4] [2+3 2+4]]
\narray([[4, 5],
\n       [5, 6]])
\nМетоды accumulate(), reduce() и reduceat() принимают необязательный аргумент - номер размерности, используемой для соответствующего действия. По умолчанию применяется нулевая размерность.
\nУниверсальные функции, помимо одного или двух необходимых параметров, позволяют задавать и еще один аргумент, для приема результата функции. Тип третьего аргумента должен строго соответствовать типу результата. Например, функция sqrt() даже от целых чисел имеет тип Float.
\n>>> from Numeric import array, sqrt, Float
\n>>> a = array([0, 1, 2])
\n>>> r = array([0, 0, 0], Float)
\n>>> sqrt(a, r)
\narray([ 0.        ,  1.        ,  1.41421356])
\n>>> print r
\n[ 0.          1.          1.41421356]
\n\nПредупреждение:
\nНе следует использовать в качестве приемника результата массив, который фигурирует в предыдущих аргументах функции, так как при этом результат может быть испорчен. Следующий пример показывает именно такой вариант:
\n>>> import Numeric
\n>>> m = Numeric.array([0, 0, 0, 1, 0, 0, 0, 0])
\n>>> add(m[:-1], m[1:], m[1:])
\narray([0, 0, 1, 1, 1, 1, 1])
\nВ таких неоднозначных случаях необходимо использовать промежуточный массив.
\n\nФункции модуля Numeric
\nСледующие функции модуля Numeric являются краткой записью некоторых наиболее употребительных сочетаний функций и методов:
\nФункция —	Аналог функции
\nsum(a, axis)—	add.reduce(a, axis)
\ncumsum(a, axis)—	add.accumulate(a, axis)
\nproduct(a, axis)—	multiply.reduce(a, axis)
\ncumproduct(a, axis) —	multiply.accumulate(a, axis)
\nalltrue(a, axis)—	logical_and.reduce(a, axis)
\nsometrue(a, axis)—	logical_or.reduce(a, axis)
\n\nПримечание:
\nПараметр axis указывает размерность.
\n\nФункции для работы с массивами
\nФункций достаточно много, поэтому подробно будут рассмотрены только две из них, а остальные сведены в таблицу.
\n\nФункция Numeric.take()
\nФункция Numeric.take() позволяет взять часть массива по заданным на определенном измерении индексам. По умолчанию номер измерения (третий аргумент) равен нулю.
\n>>> import Numeric
\n>>> a = Numeric.reshape(Numeric.arrayrange(25), (5, 5))
\n>>> print a
\n[[ 0  1  2  3  4]
\n [ 5  6  7  8  9]
\n [10 11 12 13 14]
\n [15 16 17 18 19]
\n [20 21 22 23 24]]
\n>>> print Numeric.take(a, [1], 0)
\n[ [5 6 7 8 9]]
\n>>> print Numeric.take(a, [1], 1)
\n[[ 1]
\n [ 6]
\n [11]
\n [16]
\n [21]]
\n>>> print Numeric.take(a, [[1,2],[3,4]])
\n[[[ 5  6  7  8  9]
\n  [10 11 12 13 14]]
\n [[15 16 17 18 19]
\n  [20 21 22 23 24]]]
\nВ отличие от среза, функция Numeric.take() сохраняет размерность массива, если конечно, структура заданных индексов одномерна. Результат Numeric.take(a, [[1,2],[3,4]]) показывает, что взятые по индексам части помещаются в массив со структурой самих индексов, как если бы вместо 1 было написано [5 6 7 8 9], а вместо 2 - [10 11 12 13 14] и т.д.
\n\nФункции Numeric.diagonal() и Numeric.trace()
\nФункция Numeric.diagonal() возвращает диагональ матрицы. Она имеет следующие аргументы:
\na	Исходный массив.
\noffset	Смещение вправо от \"главной\" диагонали (по умолчанию 0).
\naxis1	Первое из измерений, на которых берется диагональ (по умолчанию 0).
\naxis2	Второе измерение, образующее вместе с первым плоскость, на которой и берется диагональ. По умолчанию axis2=1.
\nФункция Numeric.trace() (для вычисления следа матрицы ) имеет те же аргументы, но суммирует элементы на диагонали. В примере ниже рассмотрены обе эти функции:
\n>>> import Numeric
\n>>> a = Numeric.reshape(Numeric.arrayrange(16), (4, 4))
\n>>> print a
\n[[ 0  1  2  3]
\n [ 4  5  6  7]
\n [ 8  9 10 11]
\n [12 13 14 15]]
\n>>> for i in range(-3, 4):
\n…   print \"Sum\", Numeric.diagonal(a, i), \"=\", Numeric.trace(a, i)
\n…
\nSum [12] = 12
\nSum [ 8 13] = 21
\nSum [ 4  9 14] = 27
\nSum [ 0  5 10 15] = 30
\nSum [ 1  6 11] = 18
\nSum [2 7] = 9
\nSum [3] = 3
\n\nФункция Numeric.choose()
\nЭта функция использует один массив с целыми числами от 0 до n для выбора значения из одного из заданных массивов:
\n>>> a = Numeric.identity(4)
\n>>> b0 = Numeric.reshape(Numeric.arrayrange(16), (4, 4))
\n>>> b1 = -Numeric.reshape(Numeric.arrayrange(16), (4, 4))
\n>>> print Numeric.choose(a, (b0, b1))
\n[[  0   1   2   3]
\n [  4  -5   6   7]
\n [  8   9 -10  11]
\n [ 12  13  14 -15]</string>


    <string name="lesson7_text">Лекция 7: Работа с данными в различных форматах в Python \n\n
Формат CSV
\nФайл в формате CSV (comma-separated values - значения, разделенные запятыми) - универсальное средство для переноса табличной информации между приложениями (электронными таблицами, СУБД, адресными книгами и т.п.). К сожалению, формат файла не имеет строго определенного стандарта, поэтому между файлами, порождаемыми различными приложениями, существуют некоторые тонкие различия. Внутри файл выглядит примерно так (файл pr.csv ):
\nname,number,text
\na,1,something here
\nb,2,\"one, two, three\"
\nc,3,\"no commas here\"
\nДля работы с CSV-файлами имеются две основные функции:
\nreader(csvfile[, dialect=\'excel\'[, fmtparam]])
\nВозвращает читающий объект, который является итератором по всем строкам заданного файла. В качестве csvfile может выступать любой объект, который поддерживает протокол итератора и возвращает строку при обращении к его методу next(). Необязательный аргумент dialect, по умолчанию равный \'excel\', указывает на необходимость использования того или иного набора свойств. Узнать доступные варианты можно с помощью csv.list_dialects(). Аргумент может быть одной из строк, возвращаемых указанной функцией, либо экземпляром подкласса класса csv.Dialect. Необязательный аргумент fmtparam служит для переназначения отдельных свойств по сравнению с заданным параметром dialect набором. Все получаемые данные являются строками.
\nwriter(csvfile[, dialect=\'excel\'[, fmtparam]])
\nВозвращает пишущий объект для записи пользовательских данных с использованием разделителя в заданный файлоподобный объект. Параметры dialect и fmtparam имеют тот же смысл, что и выше. Все данные, кроме строк, обрабатывают функцией str() перед помещением в файл.
\nВ следующем примере читается CSV-файл и записывается другой, где числа второго столбца увеличены на единицу:
\nimport csv
\ninput_file = open(\"pr.csv\", \"rb\")
\nrdr = csv.reader(input_file)
\noutput_file = open(\"pr1.csv\", \"wb\")
\nwrtr = csv.writer(output_file)
\nfor rec in rdr:
\n  try:
\n    rec[1] = int(rec[1]) + 1
\n  except:
\n    pass
\n  wrtr.writerow(rec)
\ninput_file.close()
\noutput_file.close()
\nВ результате получится файл pr1.csv следующего содержания:
\nname,number,text
\na,2,something here
\nb,3,\"one, two, three\"
\nc,4,\"no commas here\"
\nМодуль также определяет два класса для более удобного чтения и записи значений с использованием словаря. Вызовы конструкторов следующие:
\nclass DictReader(csvfile, fieldnames[, restkey=None[, restval=None[, dialect=\'excel\']]])
\nСоздает читающий объект, подобный тому, что рассматривался выше, но помещающий считываемые значения в словарь. Параметры csvfile и dialect те же, что и раньше. Параметр fieldnames задает имена полей списком. Параметр restkey задает значение ключа для помещения списка значений, для которых не хватило имен полей. Параметр restval используется как значение в том случае, если в записи не хватает значений для всех полей. Если параметр fieldnames не задан, имена полей будут прочитаны из первой записи CSV-файла. Начиная с Python 2.4, параметр fieldnames необязателен.
\nclass DictWriter(csvfile, fieldnames[, restval=\"\"[, extrasaction=\'raise\'[, dialect=\'excel\']]])
\nСоздает пишущий объект, который записывает в CSV-файл строки, получая данные из словаря. Параметры аналогичны DictReader, но fieldnames обязателен, так как он задает порядок следования полей. Параметр extrasaction указывает на то, какое действие нужно произвести в случае, когда требуемого значения нет в словаре: \'raise\' - возбудить исключение ValueError, \'ignore\' - игнорировать.
\nСоответствующий пример дан ниже. В файле pr.csv имена полей заданы в первой строке файла, поэтому можно не задавать fieldnames:
\nimport csv
\ninput_file = open(\"pr.csv\", \"rb\")
\nrdr = csv.DictReader(input_file,
\n                     fieldnames=[\'name\', \'number\', \'text\'])
\noutput_file = open(\"pr1.csv\", \"wb\")
\nwrtr = csv.DictWriter(output_file,
\n                     fieldnames=[\'name\', \'number\', \'text\'])
\nfor rec in rdr:
\n  try:
\n    rec[\'number\'] = int(rec[\'number\']) + 1
\n  except:
\n    pass
\n  wrtr.writerow(rec)
\ninput_file.close()
\noutput_file.close()
\nМодуль имеет также другие классы и функции, которые можно изучить по документации. На примере этого модуля можно увидеть общий подход к работе с файлом в некотором формате. Следует обратить внимание на следующие моменты:
\n•	Модули для работы с форматами данных обычно содержат функции или конструкторы классов, в частности Reader и Writer.
\n•	Эти функции и конструкторы возвращают объекты-итераторы для чтения данных из файла и объекты со специальными методами для записи в файл.
\n•	Для разных нужд обычно требуется иметь несколько вариантов классов читающих и пишущих объектов. Новые классы могут получаться наследованием от базовых классов либо обертыванием функций, предоставляемых модулем расширения (написанным на C). В приведенном примере DictReader и DictWriter являются обертками для функций reader() и writer() и объектов, которые они порождают.
\n\nПакет email
\nМодули пакета email помогут разобрать, изменить и сгенерировать сообщение в формате RFC 2822. Наиболее часто RFC 2822 применяется в сообщениях электронной почты в Интернете.
\nВ пакете есть несколько модулей, назначение которых (кратко) указано ниже:
\n\nMessage
\nМодуль определяет класс Message - основной класс для представления сообщения в пакете email.
\n\nParser
\nМодуль для разбора представленного в виде текста сообщения с получением объектной структуры сообщения.
\n\nHeader
\nМодуль для работы с полями, в которых используется кодировка, отличная от ASCII.
\n\nGenerator
\nПорождает текст сообщения RFC 2822 на основании объектной модели.
\n\nUtils
\nРазличные утилиты, которые решают разнообразные небольшие задачи, связанные с сообщениями.
\nВ пакете есть и другие модули, которые здесь рассматриваться не будут.
\n\nРазбор сообщения. Класс Message
\nКласс Message - центральный во всем пакете email. Он определяет методы для работы с сообщением, которое состоит из заголовка (header) и тела (payload). Поле заголовка имеет название и значение, разделенное двоеточием (двоеточие не входит ни в название, ни в значение). Названия полей нечувствительны к регистру букв при поиске значения, хотя хранятся с учетом регистра. В классе также определены методы для доступа к некоторым часто используемым сведениям (кодировке сообщения, типу содержимого и т.п.).
\nСледует заметить, что сообщение может иметь одну или несколько частей, в том числе вложенных друг в друга. Например, сообщение об ошибке доставки письма может содержать исходное письмо в качестве вложения.
\nПример наиболее употребительных методов экземпляров класса Message с пояснениями:
\n>>> import email
\n>>> input_file = open(\"pr1.eml\")
\n>>> msg = email.message_from_file(input_file)
\nЗдесь используется функция email.message_from_file() для чтения сообщения из файла pr1.eml. Сообщение можно получить и из строки с помощью функции email.message_from_string(). А теперь следует произвести некоторые операции над этим сообщением (не стоит обращать внимания на странные имена - сообщение было взято из папки СПАМ). Доступ к полям по имени осуществляется так:
\n>>> print msg[\'from\']
\n\"felton olive\" &lt;zinakinch@thecanadianteacher.com>
\n>>> msg.get_all(\'received\')
\n[\'from mail.onego.ru\\n\\tby localhost with POP3 (fetchmail-6.2.5
polling mail.onego.ru account spam)\\n\\tfor spam@localhost
(single-drop); Wed, 01 Sep 2004 15:46:33 +0400 (MSD)\',
\n\'from thecanadianteacher.com ([222.65.104.100])\\n\\tby mail.onego.ru
(8.12.11/8.12.11) with SMTP id i817UtUN026093;\\n\\tWed, 1 Sep 2004
11:30:58 +0400\']
\nСтоит заметить, что в электронном письме может быть несколько полей с именем received (в этом примере их два).
\nНекоторые важные данные можно получить в готовом виде, например, тип содержимого, кодировку:
\n>>> msg.get_content_type()
\n\'text/plain\'
\n>>> print msg.get_main_type(), msg.get_subtype()
\ntext plain
\n>>> print msg.get_charset()
\nNone
\n>>> print msg.get_params()
\n[(\'text/plain\', \'\'), (\'charset\', \'us-ascii\')]
\n>>> msg.is_multipart()
\nFalse
\nили список полей:
\n>>> print msg.keys()
\n[\'Received\', \'Received\', \'Message-ID\', \'Date\', \'From\', \'User-Agent\',
\n\'MIME-Version\', \'To\', \'Subject\', \'Content-Type\',
\n\'Content-Transfer-Encoding\', \'Spam\', \'X-Spam\']
\nТак как сообщение состоит из одной части, можно получить его тело в виде строки:
\n>>> print msg.get_payload()
\nsorgeloosheid  hullw ifesh nozama decompresssequenceframes
\n
\nBelieve it or not, I have tried several sites to b\"_\"uy presription
\nmedication. I should say that currently you are still be the best amony
\n…
\nТеперь будет рассмотрен другой пример, в котором сообщение состоит из нескольких частей. Это сообщение порождено вирусом. Оно состоит из двух частей: HTML-текста и вложенного файла с расширением cpl. Для доступа к частям сообщения используется метод walk(), который обходит все его части. Попутно следует собрать типы содержимого (в списке parts ), поля Content-Type (в ct_fields ) и имена файлов (в filenames ):
\nimport email
\nparts = []
\nct_fields = []
\nfilenames = []
\nf = open(\"virus.eml\")
\nmsg = email.message_from_file(f)
\nfor submsg in msg.walk():
\n  parts.append(submsg.get_content_type())
\n  ct_fields.append(submsg.get(\'Content-Type\', \'\'))
\n  filenames.append(submsg.get_filename())
\n  if submsg.get_filename():
\n      print \"Длина файла:\", len(submsg.get_payload())
\nf.close()
\nprint parts
\nprint ct_fields
\nprint filenames
\nВ результате получилось:
\nДлина файла: 31173
\n[\'multipart/mixed\', \'text/html\', \'application/octet-stream\']
\n[\'multipart/mixed;\\n        boundary=\"--------hidejpxkblmvuwfplzue\"\',
\n\'text/html; charset=\"us-ascii\"\',
\n\'application/octet-stream; name=\"price.cpl\"\']
\n[None, None, \'price.cpl\']
\nИз списка parts можно увидеть, что само сообщение имеет тип multipart/mixed, тогда как две его части - text/html и application/octet-stream соответственно. Только с последней частью связано имя файла (price.cpl). Файл читается методом get_payload() и вычисляется его длина.
\nКстати, в случае, когда сообщение является контейнером для других частей, get_payload() выдает список объектов-сообщений (то есть экземпляров класса Message ).
\n\nФормирование сообщения
\nЧасто возникает ситуация, когда нужно сформировать сообщение с вложенным файлом. В следующем примере строится сообщение с текстом и вложением. В качестве класса для порождения сообщения можно использовать не только Message из модуля email.Message, но и MIMEMultipart из email.MIMEMultipart (для сообщений из нескольких частей), MIMEImage (для сообщения с графическим изображением), MIMEAudio (для аудиофайлов), MIMEText (для текстовых частей):
\n# Загружаются необходимые модули и функции из модулей
\nfrom email.Header import make_header as mkh
\nfrom email.MIMEMultipart import MIMEMultipart
\nfrom email.MIMEText import MIMEText
\nfrom email.MIMEBase import MIMEBase
\nfrom email.Encoders import encode_base64
\n
\n# Создается главное сообщение и задаются некоторые поля
\nmsg = MIMEMultipart()
\nmsg[\"Subject\"] =  mkh([(\"Привет\", \"koi8-r\")])
\nmsg[\"From\"] = mkh([(\"Друг\", \"koi8-r\"), (\"&lt;friend@mail.ru>\", \"us-ascii\")])
\nmsg[\"To\"] = mkh([(\"Друг2\", \"koi8-r\"), (\"&lt;friend2@yandex.ru>\", \"us-ascii\")])
\n
\n# То, чего будет не видно, если почтовая программа поддерживает MIME
\nmsg.preamble = \"Multipart message\"
\nmsg.epilogue = \"\"
\n
\n# Текстовая часть сообщения
\ntext = u\"\"\"К письму приложен файл с архивом.\"\"\".encode(\"koi8-r\")
\nto_attach = MIMEText(text, _charset=\"koi8-r\")
\nmsg.attach(to_attach)
\n
\n# Прикладывается файл
\nfp = open(\"archive_file.zip\", \"rb\")
\nto_attach = MIMEBase(\"application\",\"octet-stream\")
\nto_attach.set_payload(fp.read())
\nencode_base64(to_attach)
\nto_attach.add_header(\"Content-Disposition\", \"attachment\",
\n                     filename=\"archive_file.zip\")
\nfp.close()
\nmsg.attach(to_attach)
\n
\nprint msg.as_string()
\nВ этом примере видно сразу несколько модулей пакета email. Функция make_header() из email.Header позволяет закодировать содержимое для заголовка:
\n>>> from email.Header import make_header
\n>>> print make_header([(\"Друг\", \"koi8-r\"), (\"&lt;friend@mail.ru>\", \"us-ascii\")])
\n=?koi8-r?b?5NLVxw==?= &lt;friend@mail.ru>
\n>>> print make_header([(u\"Друг\", \"\"), (\"&lt;friend@mail.ru>\", \"us-ascii\")])
\n=?utf-8?b?w6TDksOVw4c=?= &lt;friend@mail.ru>
\nФункция email.Encoders.encode_base64() воздействует на переданное ей сообщение и кодирует тело с помощью base64. Другие варианты: encode_quopri() - кодировать quoted printable, encode_7or8bit() - оставить семь или восемь бит. Эти функции добавляют необходимые поля.
\nАргументы конструкторов классов из MIME-модулей пакета email:
\nclass MIMEBase(_maintype, _subtype, **_params)
\nБазовый класс для всех использующих MIME сообщений (подклассов Message ). Тип содержимого задается через _maintype и _subtype.
\nclass MIMENonMultipart()
\nПодкласс для MIMEBase, в котором запрещен метод attach(), отчего он гарантированно состоит из одной части.
\nclass MIMEMultipart([_subtype[, boundary[, _subparts[, _params]]]])
\nПодкласс для MIMEBase, который является базовым для MIME-сообщений из нескольких частей. Главный тип multipart, подтип указывается с помощью _subtype.
\nclass MIMEAudio(_audiodata[, _subtype[, _encoder[, **_params]]])
\nПодкласс MIMENonMultipart. Используется для создания MIME-сообщений, содержащих аудио данные. Главный тип - audio, подтип указывается с помощью _subtype. Данные задаются параметром _audiodata.
\nclass MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])
\nПодкласс MIMENonMultipart. Используется для создания MIME-сообщений с графическим изображением. Главный тип - image, подтип указывается с помощью _subtype. Данные задаются параметром _imagedata.
\nclass MIMEMessage(_msg[, _subtype])
\nПодкласс MIMENonMultipart для класса MIMENonMultipart используется для создания MIME-объектов с главным типом message. Параметр _msg применяется в качестве тела и должен являться экземпляром класса Message или его потомков. Подтип задается с помощью _subtype, по умолчанию \'rfc822\'.
\nclass MIMEText(_text[, _subtype[, _charset]])
\nПодкласс MIMENonMultipart. Используется для создания MIME-сообщений текстового типа. Главный тип - text, подтип указывается с помощью _subtype. Данные задаются параметром _text. Посредством _charset можно указать кодировку (по умолчанию \'us-ascii\' ).
\n\nРазбор поля заголовка
\nВ примере выше поле Subject формировалось с помощью email.Header.make_header(). Разбор поля поможет провести другая функция: email.Header.decode_header(). Эта функция возвращает список кортежей, в каждом из них указан кусочек текста поля и кодировка, в которой этот текст был задан.
\nВ общем случае представить поле сообщения можно только в Unicode. Создание функции для такого преобразования предлагается в качестве упражнения.
\n\nЯзык XML
\nВ рамках одной лекции довольно сложно объяснить, что такое XML, и то, как с ним работать. В примерах используется входящий в стандартную поставку пакет xml.
\nXML (Extensible Markup Language, расширяемый язык разметки) позволяет налаживать взаимодействие между приложениями различных производителей, хранить и подвергать обработке сложно структурированные данные.
\nЯзык XML (как и HTML) является подмножеством SGML, но его применения не ограничены системой WWW. В XML можно создавать собственные наборы тегов для конкретной предметной области. В XML можно хранить и подвергать обработке базы данных и знаний, протоколы взаимодействия между объектами, описания ресурсов и многое другое.
\nНовичкам не всегда понятно, зачем нужно использовать такой достаточно многословный формат, когда можно создать свой, компактный формат для хранения тех же самых данных. Преимущество XML состоит в том, что вместе с данными он хранит и контекстную информацию: теги и их атрибуты имеют имена. Немаловажно также, что XML сегодня - единый общепринятый стандарт, для которого создано немало инструментальных средств.
\nГоворя об XML, надо иметь в виду, что XML-документы бывают формально-правильными (well-formed) и состоятельными (valid). Состоятельный XML-документ - это формально-правильный XML-документ, имеющий объявление типа документа (DTD, Document Type Definition). Объявление типа документа задает грамматику, которой текст документа на XML должен удовлетворять. Для простоты изложения здесь не будет рассматриваться DTD, предпочтительнее ограничиться формально-правильными документами.
\nДля представления букв и других символов XML использует Unicode, что сокращает проблемы с представлением символов различных алфавитов. Однако это обстоятельство необходимо помнить и не употреблять в XML восьмибитную кодировку (во всяком случае, без явного указания).
\nСледующий пример достаточно простого XML-документа дает представление об этом формате (файл expression.xml):
\n        &lt;?xml version=\"1.0\" encoding=\"iso-8859-1\"?>
\n        &lt;expression>
\n  &lt;operation type=\"+\">
\n    &lt;operand>2&lt;/operand>
\n    &lt;operand>
\n      &lt;operation type=\"*\">
\n        &lt;operand>3&lt;/operand>
\n        &lt;operand>4&lt;/operand>
\n      &lt;/operation>
\n    &lt;/operand>
\n  &lt;/operation>
\n&lt;/expression>
\nXML-документ всегда имеет структуру дерева, в корне которого сам документ. Его части, описываемые вложенными парами тегов, образуют узлы. Таким образом, ребра дерева обозначают "непосредственное вложение". Атрибуты тега можно считать листьями, как и наиболее вложенные части, не имеющие в своем составе других частей. Получается, что документ имеет древесную структуру.
\nПримечание:
\nСледует заметить, что в отличие от HTML, в XML одиночные (непарные) теги записываются с косой чертой: &lt;BR/>, а атрибуты - в кавычках. В XML имеет значение регистр букв в названиях тегов и атрибутов.
\n\nФормирование XML-документа
\nКонцептуально существуют два пути обработки XML-документа: последовательная обработка и работа с объектной моделью документа.
\nВ первом случае обычно используется SAX (Simple API for XML, простой программный интерфейс для XML). Работа SAX заключается в чтении источников данных (input source) XML-анализаторами (XML-reader) и генерации последовательности событий (events), которые обрабатываются объектами-обработчиками (handlers). SAX дает последовательный доступ к XML-документу.
\nВо втором случае анализатор XML строит DOM (Document Object Model, объектная модель документа), предлагая для XML-документа конкретную объектную модель. В рамках этой модели узлы DOM-дерева доступны для произвольного доступа,а для переходов между узлами предусмотрен ряд методов.
\nМожно применить оба этих подхода для формирования приведенного выше XML-документа.
\nЛегко заметить, что при использовании SAX команды на генерацию тегов и других частей выдаются последовательно, а вот построение одной и той же DOM можно выполнять различными последовательностями команд формирования узла и его соединения с другими узлами.
\nКонечно, указанные примеры носят довольно теоретический характер, так как на практике строить XML-документы таким образом обычно не приходится.
\n\nАнализ XML-документа
\nДля работы с готовым XML-документом нужно воспользоваться XML-анализаторами. Анализ XML-документа с порождением объекта класса Document происходит всего в одной строчке, с помощью функции parse(). Здесь стоит заметить, что кроме стандартного пакета xml можно поставить пакет PyXML или альтернативные коммерческие пакеты.
\nс помощью определенной функции output_tree(), которая принимает на входе узел и вызывается рекурсивно для всех вложенных узлов.
\nЗдесь же применяется метод normalize() для того, чтобы все текстовые фрагменты были слиты воедино (в противном случае может следовать подряд несколько узлов с текстом).
\nМожно заметить, что даже в небольшом примере использовались атрибуты узлов: node.nodeType указывает тип узла, node.nodeValue применяется для доступа к данным, node.nodeName дает имя узла (соответствует названию тега), node.attributes дает доступ к атрибутам узла. node.childNodes применяется для доступа к дочерним узлам. Этих свойств достаточно, чтобы рекурсивно обойти дерево.
\nВсе узлы являются экземплярами подклассов класса Node. Они могут быть следующих типов:
\nНазвание -	Описание -	Метод для создания
\nELEMENT_NODE -	Элемент -	createElement(tagname)
\nATTRIBUTE_NODE -	Атрибут -	createAttribute(name)
\nTEXT_NODE -	Текстовый узел -	createTextNode(data)
\nCDATA_SECTION_NODE -	Раздел CDATA
\nENTITY_REFERENCE_NODE -	Ссылка на сущность
\nENTITY_NODE -	Сущность
\nPROCESSING_INSTRUCTION_NODE -	Инструкция по обработке -	createProcessingInstruction(target, data)
\nCOMMENT_NODE -	Комментарий -	createComment(comment)
\nDOCUMENT_NODE -	Документ
\nDOCUMENT_TYPE_NODE -	Тип документа
\nDOCUMENT_FRAGMENT_NODE -	Фрагмент документа
\nNOTATION_NODE -	Нотация</string>


    <string name="lesson8_text">Лекция 8:Сетевые приложения на Python\n\n
Работа с сокетами
\nПрименяемая в IP-сетях архитектура клиент-сервер использует IP-пакеты для коммуникации между клиентом и сервером. Клиент отправляет запрос серверу, на который тот отвечает. В случае с TCP/IP между клиентом и сервером устанавливается соединение (обычно с двусторонней передачей данных), а в случае с UDP/IP - клиент и сервер обмениваются пакетами (дейтаграммамми) с негарантированной доставкой.
\nКаждый сетевой интерфейс IP-сети имеет уникальный в этой сети адрес ( IP-адрес ). Упрощенно можно считать, что каждый компьютер в сети Интернет имеет собственный IP-адрес. При этом в рамках одного сетевого интерфейса может быть несколько сетевых портов. Для установления сетевого соединения приложение клиента должно выбрать свободный порт и установить соединение с серверным приложением, которое слушает (listen) порт с определенным номером на удаленном сетевом интерфейсе. Пара IP-адрес и порт характеризуют сокет (гнездо) - начальную (конечную) точку сетевой коммуникации. Для создания соединения TCP/IP необходимо два сокета: один на локальной машине, а другой - на удаленной. Таким образом, каждое сетевое соединение имеет IP-адрес и порт на локальной машине, а также IP-адрес и порт на удаленной машине.
\nМодуль socket обеспечивает возможность работать с сокетами из Python. Сокеты используют транспортный уровень согласно семиуровневой модели OSI (Open Systems Interconnection, взаимодействие открытых систем), то есть относятся к более низкому уровню, чем большинство описываемых в этом разделе протоколов.
\nУровни модели OSI:
\n\nФизический
\nПоток битов, передаваемых по физической линии. Определяет параметры физической линии.
\n\nКанальный (Ethernet, PPP, ATM и т.п.)
\nКодирует и декодирует данные в виде потока битов, справляясь с ошибками, возникающими на физическом уровне в пределах физически единой сети.
\n\nСетевой (IP)
\nМаршрутизирует информационные пакеты от узла к узлу.
\n\nТранспортный (TCP, UDP и т.п.)
\nОбеспечивает прозрачную передачу данных между двумя точками соединения.
\n\nСеансовый
\nУправляет сеансом соединения между участниками сети. Начинает, координирует и завершает соединения.
\n\nПредставления
\nОбеспечивает независимость данных от формы их представления путем преобразования форматов. На этом уровне может выполняться прозрачное (с точки зрения вышележащего уровня) шифрование и дешифрование данных.
\n\nПриложений (HTTP, FTP, SMTP, NNTP, POP3, IMAP и т.д.)
\nПоддерживает конкретные сетевые приложения. Протокол зависит от типа сервиса.
\nКаждый сокет относится к одному из коммуникационных доменов. Модуль socket поддерживает домены UNIX и Internet. Каждый домен подразумевает свое семейство протоколов и адресацию. Данное изложение будет затрагивать только домен Internet, а именно протоколы TCP/IP и UDP/IP, поэтому для указания коммуникационного домена при создании сокета будет указываться константа socket.AF_INET
\n
\nКод программы-клиента достаточно очевиден. Метод connect() устанавливает соединение с удаленным хостом (в приведенном примере он расположен на той же машине). Данные передаются методом send() и принимаются методом recv() - аналогично тому, что происходит на сервере.
\nМодуль socket имеет несколько вспомогательных функций. В частности, функции для работы с системой доменных имен ( DNS ):
\n>>> import socket
\n>>> socket.gethostbyname(\'www.onego.ru\')
\n(\'www.onego.ru\', [], [\'195.161.136.4\'])
\n>>> socket.gethostbyaddr(\'195.161.136.4\')
\n(\'www.onego.ru\', [], [\'195.161.136.4\'])
\n>>> socket.gethostname()
\n\'rnd.onego.ru\'
\nВ новых версиях Python появилась такая функция как socket.getservbyname(). Она позволяет преобразовывать наименования Интернет-сервисов в общепринятые номера портов:
\n>>> for srv in \'http\', \'ftp\', \'imap\', \'pop3\', \'smtp\':
\n…   print socket.getservbyname(srv, \'tcp\'), srv
\n…
\n80 http
\n21 ftp
\n143 imap
\n110 pop3
\n25 smtp
\nМодуль также содержит большое количество констант для указания протоколов, типов сокетов, коммуникационных доменов и т.п. Другие функции модуля socket можно при необходимости изучить по документации.
\n\nМодуль smtplib
\nСообщения электронной почты в Интернете передаются от клиента к серверу и между серверами в основном по протоколу SMTP ( S imple M ail T ransfer P rotocol, простой протокол передачи почты). Протокол SMTP и ESMTP (расширенный вариант SMTP) описаны в RFC 821 и RFC 1869. Для работы с SMTP в стандартной библиотеке модулей имеется модуль smtplib. Для того чтобы начать SMTP-соединение с сервером электронной почты, необходимо в начале создать объект для управления SMTP-сессией с помощью конструктора класса SMTP:
\nsmtplib.SMTP([host[, port]])
\nПараметры host и port задают адрес и порт SMTP-сервера, через который будет отправляться почта. По умолчанию, port=25. Если host задан, конструктор сам установит соединение, иначе придется отдельно вызывать метод connect().
\nСледует заметить, что toaddr в сообщении (в поле To ) и при отправке могут не совпадать. Дело в том, что получатель и отправитель в ходе SMTP-сессии передается командами SMTP-протокола.
\nВ ходе одной SMTP-сессии можно отправить сразу несколько писем подряд, если не вызывать quit().
\nВ принципе, команды SMTP можно подавать и отдельно: для этого у объекта-соединения есть методы ( helo(), ehlo(), expn(), help(), mail(), rcpt(), vrfy(), send(), noop(), data() ), соответствующие одноименным командам SMTP-протокола.
\nМожно задать и произвольную команду SMTP-серверу с помощью метода docmd(). В следующем примере показан простейший сценарий, который могут использовать те, кто время от времени принимает почту на свой сервер по протоколу SMTP от почтового сервера, на котором хранится очередь сообщений для некоторого домена:
\nfrom smtplib import SMTP
\nconnect = SMTP(\'mx.abcde.ru\')
\nconnect.set_debuglevel(1)
\nconnect.docmd(\"ETRN rnd.abcde.ru\")
\nconnect.quit()
\nЭтот простенький сценарий предлагает серверу mx.abcde.ru попытаться связаться с основным почтовым сервером домена rnd.abcde.ru и переслать всю накопившуюся для него почту.
\nПри работе с классом smtplib.SMTP могут возбуждаться различные исключения. Назначение некоторых из них приведено ниже:
\nsmtplib.SMTPException
\nБазовый класс для всех исключений модуля.
\nsmtplib.SMTPServerDisconnected
\nСервер неожиданно прервал связь (или связь с сервером не была установлена).
\nsmtplib.SMTPResponseException
\nБазовый класс для всех исключений, которые имеют код ответа SMTP-сервера.
\nsmtplib.SMTPSenderRefused
\nОтправитель отвергнут
\nsmtplib.SMTPRecipientsRefused
\nВсе получатели отвергнуты сервером.
\nsmtplib.SMTPDataError
\nСервер ответил неизвестным кодом на данные сообщения.
\nsmtplib.SMTPConnectError
\nОшибка установления соединения.
\nsmtplib.SMTPHeloError
\nСервер не ответил правильно на команду HELO или отверг ее.
\n\nМодуль poplib
\nЕще один протокол - POP3 ( P ost O ffice P rotocol, почтовый протокол) - служит для приема почты из почтового ящика на сервере (протокол определен в RFC 1725).
\nДля работы с почтовым сервером требуется установить с ним соединение и, подобно рассмотренному выше примеру, с помощью SMTP-команд получить требуемые сообщения. Объект-соединение POP3 можно установить посредством конструктора класса POP3 из модуля poplib:
\npoplib.POP3(host[, port])
\nГде host - адрес POP3-сервера, port - порт на сервере (по умолчанию 110), pop_obj - объект для управления сеансом работы с POP3-сервером.
\n
\nЭти и другие методы экземпляров класса POP3 описаны ниже:
\nМетод -	Команда POP3 -	Описание
\ngetwelcome()-		Получает строку s с приветствием POP3-сервера
\nuser(name)-	USER name -	Посылает команду USER с указанием имени пользователя name. Возвращает строку с ответом сервера
\npass_(pwd)-	PASS pwd -	Отправляет пароль пользователя в команде PASS. После этой команды и до выполнения команды QUIT почтовый ящик блокируется
\napop(user, secret) -	APOP user secret -	Идентификация на сервере по APOP
\nrpop(user)-	RPOP user -	Идентификация по методу RPOP
\nstat()-	STAT -	Возвращает кортеж с информацией о почтовом ящике. В нем m - количество сообщений, l - размер почтового ящика в байтах
\nlist([num])-	LIST [num] -	Возвращает список сообщений в формате (resp, [\'num octets\', …]), если не указан num, и \"+OK num octets\", если указан. Список lst состоит из строк в формате \"num octets\".
\nretr(num)-	RETR num -	Загружает с сервера сообщение с номером num и возвращает кортеж с ответом сервера (resp, lst, octets)
\ndele(num)-	DELE num -	Удаляет сообщение с номером num
\nrset()-	RSET -	Отменяет пометки удаления сообщений
\nnoop()-	NOOP -	Ничего не делает (поддерживает соединение)
\nquit()-	QUIT -	Отключение от сервера. Сервер выполняет все необходимые изменения (удаляет сообщения) и снимает блокировку почтового ящика
\ntop(num, lines)-	TOP num lines -	Команда аналогична RETR, но загружает только заголовок и lines строк тела сообщения. Возвращает кортеж (resp, lst, octets)
\nuidl([num])-	UIDL [num] -	Сокращение от \"unique-id listing\" (список уникальных идентификаторов сообщений). Формат результата: (resp, lst, octets), если num не указан, и \"+OK num uniqid\", если указан. Список lst состоит из строк вида \"+OK num uniqid\"
\nВ этой таблице num обозначает номер сообщения (он не меняется на протяжении всей сессии), resp — ответ сервера, возвращается для любой команды, начинается с \"+OK \" для успешных операций (при неудаче возбуждается исключение poplib.proto_error ). Параметр octets обозначает количество байт в принятых данных. uniqid - идентификатор сообщения, генерируемый сервером.
\nРабота с POP3-сервером состоит из трех фаз: идентификации, транзакций и обновления. На этапе идентификации сразу после создания POP3-объекта разрешены только команды USER, PASS (иногда APOP и RPOP). После идентификации сервер получает информацию о пользователе и наступает этап транзакций. Здесь уместны остальные команды. Этап обновления вызывается командой QUIT, после которой POP3-сервер обновляет почтовый ящик пользователя в соответствии с поданными командами, а именно - удаляет помеченные для удаления сообщения.
\n\nМодули для клиента WWW
\nСтандартные средства языка Python позволяют получать из программы доступ к объектам WWW как в простых случаях, так и при сложных обстоятельствах, в частности при необходимости передавать данные формы, идентификации, доступа через прокси и т.п.
\nСтоит отметить, что при работе с WWW используется в основном протокол HTTP, однако WWW охватывает не только HTTP, но и многие другие схемы (FTP, gopher, HTTPS и т.п.). Используемая схема обычно указана в самом начале URL.
\n\nФункции для загрузки сетевых объектов
\nПростой случай получения WWW-объекта по известному URL показан в следующем примере:
\nimport urllib
\ndoc = urllib.urlopen(\"http://python.onego.ru\").read()
\nprint doc[:40]
\nФункция urllib.urlopen() создает файлоподобный объект, который читает методом read(). Другие методы этого объекта: readline(), readlines(), fileno(), close() работают как и у обычного файла, а также есть метод info(), который возвращает соответствующий полученному с сервера Message-объект. Этот объект можно использовать для получения дополнительной информации:
\n>>> import urllib
\n>>> f = urllib.urlopen(\"http://python.onego.ru\")
\n>>> print f.info()
\nDate: Sat, 25 Dec 2004 19:46:11 GMT
\nServer: Apache/1.3.29 (Unix) PHP/4.3.10
\nContent-Type: text/html; charset=windows-1251
\nContent-Length: 4291
\n>>> print f.info()[\'Content-Type\']
\ntext/html; charset=windows-1251
\nС помощью функции urllib.urlopen() можно делать и более сложные вещи, например, передавать web-серверу данные формы. Как известно, данные заполненной web-формы могут быть переданы на web-сервер с использованием метода GET или метода POST. Метод GET связан с кодированием всех передаваемых параметров после знака \"?\" в URL, а при методе POST данные передаются в теле HTTP-запроса. Оба варианта передачи представлены ниже:
\nimport urllib
\ndata = {\"search\": \"Python\"}
\nenc_data = urllib.urlencode(data)
\n
\n# метод GET
\nf = urllib.urlopen(\"http://searchengine.com/search\" + \"?\" + enc_data)
\nprint f.read()
\n
\n# метод POST
\nf = urllib.urlopen(\"http://searchengine.com/search\", enc_data)
\nprint f.read()
\nВ некоторых случаях данные имеют повторяющиеся имена. В этом случае в качестве параметра urllib.urlencode() можно использовать вместо словаря последовательность пар имя-значение:
\n>>> import urllib
\n>>> data = [(\"n\", \"1\"), (\"n\", \"3\"), (\"n\", \"4\"), (\"button\", \"Привет\"),]
\n>>> enc_data = urllib.urlencode(data)
\n>>> print enc_data
\nn=1&amp;n=3&amp;n=4&amp;button=%F0%D2%C9%D7%C5%D4
\nМодуль urllib позволяет загружать web-объекты через прокси-сервер. Если ничего не указывать, будет использоваться прокси-сервер, который был задан принятым в конкретной ОС способом. В Unix прокси-серверы задаются в переменных окружения http_proxy, ftp_proxy и т.п., в Windows прокси-серверы записаны в реестре, а в Mac OS они берутся из конфигурации Internet.
\nФункция urlretrieve() позволяет записать заданный URL сетевой объект в файл. Она имеет следующие параметры:
\nurllib.urlretrieve(url[, filename[, reporthook[, data]]])
\nЗдесь url - URL сетевого объекта, filename - имя локального файла для помещения объекта, reporthook - функция, которая будет вызываться для сообщения о состоянии загрузки, data - данные для метода POST (если он используется). Функция возвращает кортеж (filepath, headers) , где filepath - имя локального файла, в который закачан объект, headers - результат метода info() для объекта, возвращенного urlopen().
\nДля обеспечения интерактивности функция urllib.urlretrieve() вызывает время от времени функцию, заданную в reporthook(). Этой функции передаются три аргумента: количество принятых блоков, размер блока и общий размер принимаемого объекта в байтах (если он неизвестен, этот параметр равен -1).
\n\nФункции для анализа URL
\nСогласно документу RFC 2396 URL должен строиться по следующему шаблону:
\nscheme://netloc/path;parameters?query#fragment
\nгде
\nscheme
\nАдресная схема. Например: http, ftp, gopher.
\nnetloc
\nМестонахождение в сети.
\npath
\nПуть к ресурсу.
\nparams
\nПараметры.
\nquery
\nСтрока запроса.
\nfragment
\nИдентификатор фрагмента.
\nОдна из функций уже использовалась для формирования URL - urllib.urlencode(). Кроме нее в модуле urllib имеются и другие функции:
\nquote(s, safe=\'/\')
\nФункция экранирует символы в URL, чтобы их можно было отправлять на web-сервер. Она предназначена для экранирования пути к ресурсу, поэтому оставляет \'/\' как есть. Например:
\n>>> urllib.quote(\"rnd@onego.ru\")
\n\'rnd%40onego.ru\'
\n>>> urllib.quote(\"a = b + c\")
\n\'a%20%3D%20b%20%2B%20c\'
\n>>> urllib.quote(\"0/1/1\")
\n\'0/1/1\'
\n>>> urllib.quote(\"0/1/1\", safe=\"\")
\n\'0%2F1%2F1\'
\nquote_plus(s, safe=\'\')
\nФункция экранирует некоторые символы в URL (в строке запроса), чтобы их можно было отправлять на web-сервер. Аналогична quote(), но заменяет пробелы на плюсы.
\nunquote(s)
\nПреобразование, обратное quote(). Пример:
\n>>> urllib.unquote(\'a%20%3D%20b%20%2B%20c\')
\n\'a = b + c\'
\nПреобразование, обратное quote_plus(). Пример:
\n>>> urllib.unquote_plus(\'a+=+b+%2B+c\')
\n\'a = b + c\'
\nДля анализа URL можно использовать функции из модуля urlparse:
\nurlparse(url, scheme=\'\', allow_fragments=1)
\nРазбирает URL в 6 компонентов (сохраняя экранирование символов): scheme://netloc/path;params?query#frag
\nurlsplit(url, scheme=\'\', allow_fragments=1)
\nРазбирает URL в 5 компонентов (сохраняя экранирование символов): scheme://netloc/path?query#frag
\nurlunparse((scheme, netloc, url, params, query, fragment))
\nСобирает URL из 6 компонентов.
\nurlunsplit((scheme, netloc, url, query, fragment))
\nСобирает URL из 5 компонентов.
\nПример:
\n>>> from urlparse import urlsplit, urlunsplit
\n>>> URL = \"http://google.com/search?q=Python\"
\n>>> print urlsplit(URL)
\n(\'http\', \'google.com\', \'/search\', \'q=Python\', \'\')
\n>>> print urlunsplit(
\n…     (\'http\', \'google.com\', \'/search\', \'q=Python\', \'\'))
\nhttp://google.com/search?q=Python
\nЕще одна функция того же модуля urlparse позволяет корректно соединить две части URL - базовую и относительную:
\n>>> import urlparse
\n>>> urlparse.urljoin(\'http://python.onego.ru\', \'itertools.html\')
\n\'http://python.onego.ru/itertools.html\'</string>


    <string name="lesson9_text">Лекция 9. Работа с базой данных в Python\n\n
Основные понятия реляционной СУБД
\n\nРеляционная база данных - это набор таблиц с данными.
\n\nТаблица - это прямоугольная матрица, состоящая из строк и столбцов. Таблица задает отношение (relation).
\n\nСтрока - запись, состоящая из полей - столбцов. В каждом поле может содержаться некоторое значение, либо специальное значение NULL (пусто). В таблице может быть произвольное количество строк. Для реляционной модели порядок расположения строк не определен и не важен.
\nКаждый столбец в таблице имеет собственное имя и тип.
\n\nЧто такое DB-API 2
\nВынесенная в заголовок аббревиатура объединяет два понятия: DB (Database, база данных) и API (Application Program Interface, интерфейс прикладной программы).
\nТаким образом, DB-API определяет интерфейс прикладной программы с базой данных. Этот интерфейс, описываемый ниже, должны реализовывать все модули расширения, которые служат для связи Python-программ с базами данных. Единый API (в настоящий момент его вторая версия) позволяет абстрагироваться от марки используемой базы данных, при необходимости довольно легко менять одну СУБД на другую, изучив всего один набор функций и методов.
\nDB-API 2.0 описан в PEP 249 (сайт http://www.python.org/dev/peps/pep-0249/), и данное ниже описание основано именно на нем.
\n\nОписание DB API 2.0
\nDB API 2.0 регламентирует интерфейсы модуля расширения для работы с базой данных, методы объекта-соединения с базой, объекта-курсора текущей обрабатываемой записи, объектов различных для типов данных и их конструкторов, а также содержит рекомендации для разработчиков по реализации модулей. На сегодня Python поддерживает через модули расширения многие известные базы данных (уточнить можно на web-странице по адресу http://www.python.org/topics/database/). Ниже рассматриваются почти все положения DB-API за исключением рекомендаций для разработчиков новых модулей.
\n\nИнтерфейс модуля
\nЗдесь необходимо сказать о том, что должен предоставлять модуль для удовлетворения требований DB-API 2.0.
\nДоступ к базе данных осуществляется с помощью объекта-соединения (connection object). DB-API-\nсовместимый модуль должен предоставлять функцию-конструктор connect() для класса объектов-соединений. Конструктор должен иметь следующие именованные параметры:
\n•	dsn Название источника данных в виде строки
\n•	user Имя пользователя
\n•	password Пароль
\n•	host Адрес хоста, на котором работает СУБД
\n•	database Имя базы данных.
\nМетоды объекта-соединения будут рассмотрены чуть позже.
\nМодуль определяет константы, содержащие его основные характеристики:
\n•	apilevel Версия DB-API (\"1.0\" или \"2.0\").
\n•	threadsafety Целочисленная константа, описывающая возможности модуля при использовании потоков управления:
\n	0 Модуль не поддерживает потоки.
\n	1 Потоки могут совместно использовать модуль, но не соединения.
\n	2 Потоки могут совместно использовать модуль и соединения.
\n	3 Потоки могут совместно использовать модуль, соединения и курсоры. (Под совместным использованием здесь понимается возможность использования упомянутых ресурсов без применения семафоров).
\n•	paramstyle Тип используемых пометок при подстановке параметров. Возможны следующие значения этой константы:
\n	\"format\" Форматирование в стиле языка ANSI C (например, \"%s\", \"%i\" ).
\n	\"pyformat\" Использование именованных спецификаторов формата в стиле Python ( \"%(item)s\" )
\n	\"qmark\" Использование знаков \"?\" для пометки мест подстановки параметров.
\n	\"numeric\" Использование номеров позиций ( \":1\" ).
\n	\"named\" Использование имен подставляемых параметров ( \":name\" ).
\nМодуль должен определять ряд исключений для обозначения типичных исключительных ситуаций: Warning (предупреждение), Error (ошибка), InterfaceError (ошибка интерфейса), DatabaseError (ошибка, относящаяся к базе данных). А также подклассы этого последнего исключения: DataError (ошибка обработки данных), OperationalError (ошибка в работе или сбой соединения с базой данных), IntegrityError (ошибка целостности базы данных), InternalError (внутренняя ошибка базы данных), ProgrammingError (программная ошибка, например, ошибка в синтаксисе SQL-запроса), NotSupportedError (при отсутствии поддержки запрошенного свойства).
\n\nОбъект-соединение
\nОбъект-соединение, получаемый в результате успешного вызова функции connect(), должен иметь следующие методы:
\n•	close() Закрывает соединение с базой данных.
\n•	commit() Завершает транзакцию.
\n•	rollback() Откатывает начатую транзакцию (восстанавливает исходное состояние). Закрытие соединения при незавершенной транзакции автоматически производит откат транзакции.
\n•	cursor() Возвращает объект-курсор, использующий данное соединение. Если база данных не поддерживает курсоры, модуль сопряжения должен их имитировать.
\nПод транзакцией понимается группа из одной или нескольких операций, которые изменяют базу данных. Транзакция соответствует логически неделимой операции над базой данных, а частичное выполнение транзакции приводит к нарушению целостности БД. Например, при переводе денег с одного счета на другой операции по уменьшению первого счета и увеличению второго являются транзакцией. Методы commit() и rollback() обозначают начало и конец транзакции в явном виде. Кстати, не все базы данных поддерживают механизм транзакций.
\nСледует отметить, что в зависимости от реализации DB-API 2.0 модуля, необходимо сохранять ссылку на объект-соединение в продолжение работы курсоров этого соединения. В частности, это означает, что нельзя сразу же получать объект-курсор, не привязывая объект-соединение к некоторому имени. Также нельзя оставлять объект-соединение в локальной переменной, возвращая из функции или метода объект-курсор.
\n\nОбъект-курсор
\nКурсор (от англ. cursor - CURrrent Set Of Records, текущий набор записей) служит для работы с результатом запроса. Результатом запроса обычно является одна или несколько прямоугольных таблиц со столбцами-полями и строками-записями. Приложение может читать и обрабатывать полученные таблицы и записи в таблице по одной, поэтому в курсоре хранится информация о текущей таблице и записи. Конкретный курсор в любой момент времени связан с выполнением одной SQL-инструкции.
\nАтрибуты объекта-курсора тоже определены DB-API:
\n•	arraysize Атрибут, равный количеству записей, возвращаемых методом fetchmany(). По умолчанию равен 1.
\n•	callproc(procname[, params]) Вызывает хранимую процедуру procname с параметрами из изменчивой последовательности params. Хранимая процедура может изменить значения некоторых параметров последовательности. Метод может возвратить результат, доступ к которому осуществляется через fetch -методы.
\n•	close() Закрывает объект-курсор.
\n•	description Этот доступный только для чтения атрибут является последовательностью из семиэлементных последовательностей. Каждая из этих последовательностей содержит информацию, описывающую один столбец результата:
\n(name, type_code, display_size, internal_size, precision, scale, null_OK)
\nПервые два элемента (имя и тип) обязательны, а вместо остальных (размер для вывода, внутренний размер, точность, масштаб, возможность задания пустого значения) может быть значение None. Этот атрибут может быть равным None для операций, не возвращающих значения.
\n•	execute(operation[, parameters]) Исполняет запрос к базе данных или команду СУБД. Параметры ( parameters ) могут быть представлены в принятой в базе данных нотации в соответствии с атрибутом paramstyle, описанным выше.
\n•	executemany(operation, seq_of_parameters) Выполняет серию запросов или команд, подставляя параметры в заданный шаблон. Параметр seq_of_parameters задает последовательность наборов параметров.
\n•	fetchall() Возвращает все (или все оставшиеся) записи результата запроса.
\n•	fetchmany([size]) Возвращает следующие несколько записей из результатов запроса в виде последовательности последовательностей. Пустая последовательность означает отсутствие данных. Необязательный параметр size указывает количество возвращаемых записей (реально возвращаемых записей может быть меньше). По умолчанию size равен атрибуту arraysize объекта-курсора.
\n•	fetchone() Возвращает следующую запись (в виде последовательности) из результата запроса или None при отсутствии данных.
\n•	nextset() Переводит курсор к началу следующего набора данных, полученного в результате запроса (при этом часть записей в предыдущем наборе может остаться непрочитанной). Если наборов больше нет, возвращает None. Не все базы данных поддерживают возврат нескольких наборов результатов за одну операцию.
\n•	rowcount Количество записей, полученных или затронутых в результате выполнения последнего запроса. В случае отсутствия execute-запросов или невозможности указать количество записей равен -1.
\n•	setinputsizes(sizes) Предопределяет области памяти для параметров, используемых в операциях. Аргумент sizes задает последовательность, где каждый элемент соответствует одному входному параметру. Элемент может быть объектом-типом соответствующего параметра или целым числом, задающим длину строки. Он также может иметь значение None, если о размере входного параметра ничего нельзя сказать заранее или он предполагается очень большим. Метод должен быть вызван до execute-методов.
\n•	setoutputsize(size[, column]) Устанавливает размер буфера для выходного параметра из столбца с номером column. Если column не задан, метод устанавливает размер для всех больших выходных параметров. Может использоваться, например, для получения больших бинарных объектов ( B inary L arge O bject, BLOB ).
\n\nОбъекты-типы
\nDB-API 2.0 предусматривает названия для объектов-типов, используемых для описания полей базы данных:
\nОбъект -	Тип
\nSTRING -	Строка и символ
\nBINARY -	Бинарный объект
\nNUMBER -	Число
\nDATETIME -	Дата и время
\nROWID -	Идентификатор записи
\nNone -	NULL-значение (отсутствующее значение)
\nС каждым типом данных (в реальности это - классы) связан конструктор. Совместимый с DB-API модуль должен определять следующие конструкторы:
\n•	Date(год, месяц, день) Дата.
\n•	Time(час, минута, секунда) Время.
\n•	Timestamp(год, месяц, день, час, минута, секунда) Дата-время.
\n•	DateFromTicks(secs) Дата в виде числа секунд secs от начала эпохи (1 января 1970 года).
\n•	TimeFromTicks(secs) Время, то же.
\n•	TimestampFromTicks(secs) Дата-время, то же.
\n•	Binary(string) Большой бинарный объект на основании строки string.
\n\nРабота с базой данных из Python-приложения
\nДалее в лекции на конкретных примерах будет показано, как работать с базой данных из программы на языке Python. Нужно отметить, что здесь не ставится цели постичь премудрости языка запросов (это тема отдельного курса). Простые примеры позволят понять, что при программировании на Python доступ к базе данных не сложнее доступа к другим источникам данных (файлам, сетевым объектам).
\nИменно поэтому для демонстрации выбрана СУБД SQLite, работающая как под Unix, так и под Windows. Кроме установки собственно SQLite (сайт http://sqlite.org) и модуля сопряжения с Python (http://pysqlite.org), каких-либо дополнительных настроек проводить не требуется, так как SQLite хранит данные базы в отдельном файле: сразу приступать к созданию таблиц, занесению в них данных и произведению запросов нельзя. Выбранная СУБД (в силу своей \"легкости\") имеет одну существенную особенность: за одним небольшим исключением, СУБД SQLite не обращает внимания на типы данных (она хранит все данные в виде строк), поэтому модуль расширения sqlite для Python проделывает дополнительную работу по преобразованию типов. Кроме того, СУБД SQLite поддерживает достаточно большое подмножество свойств стандарта SQL92, оставаясь при этом небольшой и быстрой, что немаловажно, например, для web-приложений. Достаточно сказать, что SQLite поддерживает даже транзакции.
\nЕще раз стоит повторить, что выбор учебной базы данных не влияет на синтаксис использованных средств, так как модуль sqlite, который будет использоваться, поддерживает DB-API 2.0, а значит, переход на любую другую СУБД потребует минимальных изменений в вызове функции connect() и, возможно, использования более удачных типов данных, свойственных целевой СУБД.
\nСхематично работа с базой данных может выглядеть примерно так:
\n•	Подключение к базе данных (вызов connect() с получением объекта-соединения).
\n•	Создание одного или нескольких курсоров (вызов метода объекта-соединения cursor() с получением объекта-курсора).
\n•	Исполнение команды или запроса (вызов метода execute() или его вариантов).
\n•	Получение результатов запроса (вызов метода fetchone() или его вариантов).
\n•	Завершение транзакции или ее откат (вызов метода объекта-соединения commit() или rollback() ).
\n•	Когда все необходимые транзакции произведены, подключение закрывается вызовом метода close() объекта-соединения.
\n\nСоздание базы данных
\nДля создания базы данных нужно установить, какие таблицы (и другие объекты, например индексы) в ней будут храниться, а также определить структуры таблиц (имена и типы полей).
\nЗадача - создание базы данных, в которой будет храниться телепрограмма. В этой базе будет таблица со следующими полями:
\n•	tvdate,
\n•	tvweekday,
\n•	tvchannel,
\n•	tvtime1,
\n•	tvtime2,
\n•	prname,
\n•	prgenre.
\nЗдесь tvdate - дата, tvchannel - канал, tvtime1 и tvtime2 - время начала и конца передачи, prname - название, prgenre - жанр. Конечно, в этой таблице есть функциональная зависимость ( tvweekday вычисляется на основе tvdate и tvtime1 ), но из практических соображений БД к нормальным формам приводиться не будет. Кроме того, будет создана таблица с названиями дней недели (устанавливает соответствие между номером дня и днем недели):
\n•	weekday,
\n•	wdname.
\nЗдесь просто исполняются SQL-инструкции, и обрабатывается ошибка базы данных, если таковая случится (например, при попытке создать таблицу с уже существующим именем). Для того чтобы таблицы создавались независимо, используется commit().
\n\nДругие СУБД и Python
\nМодуль sqlite дает прекрасные возможности для построения небольших и быстрых баз данных, однако для полноты изложения предлагается обзор модулей расширения Python для других СУБД.
\nВыше везде импортировался модуль sqlite, с изменением его имени на db. Это было сделано не случайно. Дело в том, что подобные модули, поддерживающие DB-API 2.0, есть и для других СУБД, и даже не в единственном числе. Согласно информации на сайте www.python.org DB-API 2.0-совместимые модули для Python имеют следующие СУБД или протоколы доступа к БД:
\n•	zxJDBC Доступ по JDBC.
\n•	MySQL Для СУБД MySQL.
\n•	mxODBC Доступ по ODBC, продается фирмой eGenix (http://www.egenix.com).
\n•	DCOracle2, cx_Oracle Для СУБД Oracle.
\n•	PyGresQL, psycopg, pyPgSQL Для СУБД PostgreSQL.
\n•	Sybase Для Sybase.
\n•	sapdbapi Для СУБД SAP.
\n•	KInterbasDB Для СУБД Firebird (это потомок Interbase).
\n•	PyADO Адаптер к Microsoft ActiveX Data Objects (только под Windows).
</string>


    <string name="lesson10_text">Лекция 10: Интеграция Python с другими языками программирования\n\n
C API
\nДоступные из языка Python модули расширяются за счет модулей расширения (extension modules). Модули расширения можно писать на языке C или C++ и вызывать из программ на Python. В этой лекции речь пойдет о реализации Python, называемой CPython(Jython, реализация Python на платформе Java не будет рассматриваться).
\nСама необходимость использования языка C может возникнуть, если реализуемый алгоритм, будучи запрограммирован на Python, работает медленно. Например, высокопроизводительные операции с массивами модуля Numeric (о котором говорилось в одной из предыдущих лекций) написаны на языке C. Модули расширения позволяют объединить эффективность порождаемого компилятором C/C++ кода c удобством и гибкостью интерпретатора Python. Необходимые сведения для создания модулей расширения для Python даны в исчерпывающем объеме в стандартной документации, а именно в документе \"Python/C API Reference Manual\" (справочное руководство по \"Python/C API\"). Здесь будут рассмотрены лишь основные принципы построения модуля расширения, без детальных подробностей об API. Стоит заметить, что возможности Python равно доступны и в C++, просто они выражены в C-декларациях, которые можно использовать в C++.
\nВсе необходимые для модуля расширения определения находятся в заголовочном файле Python.h, который должен находится где-то на пути заголовочных файлов компилятора C/C++. Следует пользоваться теми же версиями библиотек, с которыми был откомпилирован Python. Желательно, и той же маркой компилятора C/C++.
\nСвязь с интерпретатором Python из кода на C осуществляется путем вызова функций, определенных в интерпретаторе Python. Все функции начинаются на Py или _Py, потому во избежание конфликтов в модулях расширения не следует определять функций с подобными именами.
\nЧерез C API доступны все встроенные возможности языка Python (при необходимости, детальнее изучить этот вопрос можно по документации):
\n•	высокоуровневый интерфейс интерпретатора (функции и макросы Py_Main(), PyRun_String(), PyRun_File(), Py_CompileString(), PyCompilerFlags() и т.п.),
\n•	функции для работы со встроенным интерпретатором и потоками ( Py_Initialize(), Py_Finalize(), Py_NewInterpreter(), Py_EndInterpreter(), Py_SetProgramName() и другие),
\n•	управление подсчетом ссылок (макросы Py_INCREF(), Py_DECREF(), Py_XINCREF(), Py_XDECREF(), Py_CLEAR() ). Требуется при создании или удалении Python-объектов в C/C++-коде.
\n•	обработка исключений ( PyErr* -функции и PyExc_* -константы, например, PyErr_NoMemory() и PyExc_IOError )
\n•	управление процессом и сервисы операционной системы ( Py_FatalError(), Py_Exit(), Py_AtExit(), PyOS_CheckStack(), и другие функции/макросы PyOS* ),
\n•	импорт модулей ( PyImport_Import() и другие),
\n•	поддержка сериализации объектов ( PyMarshal_WriteObjectToFile(), PyMarshal_ReadObjectFromFile() и т.п.)
\n•	поддержка анализа строки аргументов ( PyArg_ParseTuple(), PyArg_VaParse(), PyArg_ParseTupleAndKeywords(), PyArg_VaParseTupleAndKeywords(), PyArg_UnpackTuple() и Py_BuildValue() ). С помощью этих функций облегчается задача получения в коде на C параметров, заданных при вызове функции из Python. Функции PyArg_Parse* принимают в качестве аргумента строку формата полученных аргументов,
\n•	поддержка протоколов абстрактных объектов: + Протокол объекта ( PyObject_Print(), PyObject_HasAttrString(), PyObject_GetAttrString(), PyObject_HasAttr(), PyObject_GetAttr(), PyObject_RichCompare(), …, PyObject_IsInstance(), PyCallable_Check(), PyObject_Call(), PyObject_Dir() и другие). То, что должен уметь делать любой объект Python + Протокол числа ( PyNumber_Check(), PyNumber_Add(), …, PyNumber_And(), …, PyNumber_InPlaceAdd(), …, PyNumber_Coerce(), PyNumber_Int(), …). То, что должен делать любой объект, представляющий число + Протокол последовательности ( PySequence_Check(), PySequence_Size(), PySequence_Concat(), PySequence_Repeat(), PySequence_InPlaceConcat(), …, PySequence_GetItem(), …, PySequence_GetSlice(), PySequence_Tuple(), PySequence_Count(), …) + Протокол отображения (например, словарь является отображением) (функции: PyMapping_Check(), PyMapping_Length(), PyMapping_HasKey(), PyMapping_Keys(), …, PyMapping_SetItemString(), PyMapping_GetItemString() и др.) + Протокол итератора ( PyIter_Check(), PyIter_Next() ) + Протокол буфера ( PyObject_AsCharBuffer(), PyObject_AsReadBuffer(), PyObject_AsWriteBuffer(), PyObject_CheckReadBuffer() )
\n•	поддержка встроенных типов данных. Аналогично описанному в предыдущем пункте, но уже для конкретных встроенных типов данных. Например: + Булевский объект ( PyBool_Check() - проверка принадлежности типу PyBool_Type, Py_False - объект False, Py_True - объект True,
\n•	управление памятью (то есть кучей интерпретатора Python) (функции PyMem_Malloc(), PyMem_Realloc(), PyMem_Free(), PyMem_New(), PyMem_Resize(), PyMem_Del() ). Разумеется, можно применять и средства выделения памяти C/C++, однако, в этом случае не будут использоваться преимущества управления памятью интерпретатора Python (сборка мусора и т.п.). Кроме того, освобождение памяти нужно производить тем же способом, что и ее выделение. Еще раз стоит напомнить, что повторное освобождение одной и той же области памяти (а равно использование области памяти после ее освобождения) чревато серьезными ошибками, которые компилятор C не имеет возможности распознать.
\n•	структуры для определения объектов встроенных типов ( PyObject, PyVarObject и много других)
\n\nПримечание
\nПод протоколом здесь понимается набор методов, которые должен поддерживать тот или иной класс для организации операций со своими экземплярами. Эти методы доступны не только из Python (например, len(a) дает длину последовательности), но и из кода на C ( PySequence_Length() ).
\n\nНаписание модуля расширения
\nЕсли необходимость встроить Python в программу возникает нечасто, то его расширение путем написания модулей на C/C++ - довольно распространенная практика. Изначально Python был нацелен на возможность расширения, поэтому в настоящий момент очень многие C/C++-библиотеки имеют привязки к Python.
\nПривязка к Python, хотя и может быть несколько автоматизирована, все же это процесс творческий. Дело в том, что если предполагается интенсивно использовать библиотеку в Python, ее привязку желательно сделать как можно более тщательно. Возможно, в ходе привязки будет сделана объектно-ориентированная надстройка или другие архитектурные изменения, которые позволят упростить использование библиотеки.
\nВ качестве примера можно привести выдержку из исходного кода модуля md5, который реализует функцию для получения md5-дайджеста. Модуль приводится в целях иллюстрации (то есть, с сокращениями). Модуль вводит собственный тип данных, MD5Type, поэтому можно увидеть не только реализацию функций, но и способ описания встроенного типа. В рамках этого курса не изучить все тонкости программирования модулей расширения, главное понять дух этого занятия.
\nПеред тем, как приступать к созданию своего модуля, следует убедиться, что это целесообразно: подходящего модуля еще не создано и реализация в виде чистого Python неэффективна. Если создан действительно полезный модуль, его можно предложить для включения в поставку Python. Для этого нужно просто связаться с кем-нибудь из разработчиков по электронной почте или предложить модуль в виде \"патча\" через http://sourceforge.net.
\n\nПример встраивания интерпретатора в программу на C
\nИнтерпретатор Python может быть встроен в программу на C с использованием C API.
\nЗдесь следует отметить следующие моменты:
\n•	программу необходимо компилировать вместе с библиотекой libpython соответствующей версии (для этого используется опция -l, за которой следует имя библиотеки) и еще с библиотеками, которые требуются для Python: libpthread, libm, libutil и т.п.)
\n•	опция pic порождает код, не зависящий от позиции, что позволяет в дальнейшем динамически компоновать код
\n•	обычно требуется явно указать каталог, в котором лежит заголовочный файл Python.h (в gcc это делается опцией -I )
\n•	чтобы получившийся исполняемый файл мог корректно предоставлять имена для динамически загружаемых модулей, требуется передать компоновщику опцию -E: это можно сделать из gcc с помощью опции -Wl, -E. (В противном случае, модуль time, а это модуль расширения в виде динамически загружаемого модуля, не будет работать из-за того, что не увидит имен, определенных в libpython)
\nЗдесь же следует сделать еще одно замечание: программа, встраивающая Python, не должна много раз выполнять Py_Initialize() и Py_Finalize(), так как это может приводить к утечке памяти. Сам же интерпретатор Python очень стабилен и в большинстве случаев не дает утечек памяти.
\n\nИспользование SWIG
\nSWIG (Simplified Wrapper and Interface Generator, упрощенный упаковщик и генератор интерфейсов) - это программное средство, сильно упрощающее (во многих случаях - автоматизирующее) использование библиотек, написанных на C и C++, а также на других языках программирования, в том числе (не в последнюю очередь!) на Python. Нужно отметить, что SWIG обеспечивает достаточно полную поддержку практически всех возможностей C++, включая предобработку, классы, указатели, наследование и даже шаблоны C++. Последнее очень важно, если необходимо создать интерфейс к библиотеке шаблонов.
\nПользоваться SWIG достаточно просто, если уметь применять компилятор и компоновщик (что в любом случае требуется при программировании на C/C++).
\n\nПростой пример использования SWIG
\nПредположим, что есть программа на C, реализующая некоторую функцию (пусть это будет вычисление частоты появления различных символов в строке):
\n/* File : freq.c */
\n                #include &lt;stdlib.h>
\n
\n                int * frequency(char s[]) {
\n                  int *freq;
\n                  char *ptr;
\n                  freq = (int*)(calloc(256, sizeof(int)));
\n                  if (freq != NULL)
\n                    for (ptr = s; *ptr; ptr++)
\n                      freq[*ptr] += 1;
\n                  return freq;
\n                }
\nДля того чтобы можно было воспользоваться этой функцией из Python, нужно написать интерфейсный файл (расширение .i) примерно следующего содержания:
\n/* File : freq.i */
\n                %module freq
\n
\n                %typemap(out) int * {
\n                  int i;
\n                  $result = PyTuple_New(256);
\n                  for(i=0; i&lt;256; i++)
\n                    PyTuple_SetItem($result, i, PyLong_FromLong($1[i]));
\n                  free($1);
\n                }
\n
\n                extern int * frequency(char s[]);
\nИнтерфейсные файлы содержат инструкции самого SWIG и фрагменты C/C++-кода, возможно, с макровключениями (в примере выше: $result, $1 ). Следует заметить, что для преобразования массива целых чисел в кортеж элементов типа long, необходимо освободить память из-под исходного массива, в котором подсчитывались частоты.
\nТеперь (подразумевая, что используется компилятор gcc), создание модуля расширения может быть выполнено примерно так:
\nswig -python freq.i
\n                gcc -c -fpic freq_wrap.c freq.c  -DHAVE_CONFIG_H
\n                   -I/usr/local/include/python2.3 -I/usr/local/lib/python2.3/config
\n                gcc -shared freq.o freq_wrap.o -o _freq.so
\nПосле этого в рабочем каталоге появляется файлы _freq.so и freq.py, которые вместе и дают доступ к требуемой функции:
\n>>> import freq
\n                >>> freq.frequency(\"ABCDEF\")[60:75]
\n                (0L, 0L, 0L, 0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 0L, 0L, 0L, 0L)
\nПомимо этого, можно посмотреть на содержимое файла freq_wrap.c, который был порожден SWIG: в нем, среди прочих вспомогательных определений, нужных самому SWIG, можно увидеть что-то подобное проиллюстрированному выше примеру модуля md5.
\nСтоит еще раз напомнить, что в отличие от Python, в языке C/C++ управление памятью должно происходить в явном виде. Именно поэтому добавлена функция free() при преобразовании типа. Если этого не сделать, возникнут утечки памяти. Эти утечки можно обнаружить, при многократном выполнении функции:
\n>>> import freq
\n                >>> for i in xrange(1000000):
\n                …   dummy =  freq.frequency(\"ABCDEF\")
\n                >>>
\nЕсли функция freq.frequency() имеет утечки памяти, выполняемый процесс очень быстро займет всю имеющуюся память.
\n\nИнтеграция Python и других систем программирования
\nЯзык программирования Python является сценарным языком, а значит его основное назначение - интеграция в единую систему разнородных программных компонентов. Выше рассматривалась (низкоуровневая) интеграция с C/C++-приложениями. Нужно заметить, что в большинстве случаев достаточно интеграции с использованием протокола. Например, интегрируемые приложения могут общаться через XML-RPC, SOAP, CORBA, COM, .NET и т.п. В случаях, когда приложения имеют интерфейс командной строки, их можно вызывать из Python и управлять стандартным вводом-выводом, переменными окружения. Однако есть и более интересные варианты интеграции.
\nСовременное состояние дел по излагаемому вопросу можно узнать по адресу: http://www.python.org/moin/IntegratingPythonWithOtherLanguages
\n\nJava
\nДокументация по Jython (это реализация Python на Java-платформе) отмечает, что Jython обладает следующими неоспоримыми преимуществами над другими языками, использующими Java-байт-код:
\n•	Jython-код динамически компилирует байт-коды Java, хотя возможна и статическая компиляция, что позволяет писать апплеты, сервлеты и т.п.;
\n•	Поддерживает объектно-ориентированную модель Java, в том числе, возможность наследовать от абстрактных Java-классов;
\n•	Jython является реализацией Python - языка с практичным синтаксисом, обладающего большой выразительностью, что позволяет сократить сроки разработки приложений в разы.
\nПравда, имеются и некоторые ограничения по сравнению с \"обычным\" Python. Например, Java не поддерживает множественного наследования, поэтому в некоторых версиях Jython нельзя наследовать классы от нескольких Java-классов (в то же время, множественное наследование поддерживается для Python-классов).
\nПрограммы на Jython можно компилировать в Java и собирать в jar-архивы. Для создания jar-архива на основе модуля (или пакета) можно применить команду jythonc, которая входит в комплект Jython. Из командной строки это можно сделать примерно так:
\njythonс -d -c -j lns.jar lines.py
\nДля запуска приложения достаточно запустить lines из командной строки:
\njava -classpath \"$CLASSPATH\" lines
\nВ переменной $CLASSPATH должны быть пути к архивам lns.jar и jython.jar.
\n\nProlog
\nДля тех, кто хочет использовать Prolog из Python, существует несколько возможностей:
\n•	Версия GNU Prolog (сайт: http://gprolog.sourceforge.net) интегрируется с Python посредством пакета bedevere (сайт: http://bedevere.sourceforge.net)
\n•	Имеется пакет PyLog (http://www.gocept.com/angebot/opensource/Pylog) для работы с SWI-Prolog (http://www.swi-prolog.org) из Python
\n•	Можно использовать пакет pylog (доступен с сайта: http://christophe.delord.free.fr/en/pylog/), который добавляет основные возможности Prolog в Python
\nЭти три варианта реализуют различные способы интеграции возможностей Prolog в Python. Первый вариант использует SWIG, второй организует общение с Prolog-системой через конвейер, а третий является специализированной реализацией Prolog.
\nРазумеется, это не \"настоящий\" Prolog, но с помощью модуля pylog любой, кому требуются логические возможности Prolog в Python, может написать программу с использованием Prolog-синтаксиса.
\n\nOCaml
\nЯзык программирования OCaml - это язык функционального программирования (семейства ML, что означает Meta Language), созданный в институте INRIA, Франция. Важной особенностью OCaml является то, что его компилятор порождает исполняемый код, по быстродействию сравнимый с С, родной для платформ, на которых OCaml реализован. В то же время, будучи функциональным по своей природе, он приближается к Python по степени выразительности. Именно поэтому для OCaml была создана библиотека Pycaml, фактически реализующая аналог C API для OCaml. Таким образом, в программах на OCaml могут использоваться модули языка Python, в них даже может быть встроен интерпретатор Python. Для Python имеется большое множество адаптированных C-библиотек, это дает возможность пользователям OCaml применять в разработке комбинированное преимущество Python и OCaml. Минусом является только необходимость знать функции Python/C API, имена которого использованы для связи OCaml и Python.
\nСледующий пример (из Pycaml) показывает программу для OCaml, которая определяет модуль для Python на OCaml и вызывает встроенный интерпретатор Python:
\n\nPyrex
\nДля написания модулей расширения можно использовать специальный язык - Pyrex - который совмещает синтаксис Python и типы данных C. Компилятор Pyrex написан на Python и превращает исходный файл (например, primes.pyx) в файл на C - готовый для компиляции модуль расширения. Язык Pyrex заботится об управлении памятью, удаляя после себя ставшие ненужными объекты. Пример файла из документации к Pyrex (для вычисления простых чисел):
\nСледует отметить, что для простых операций Pyrex применяет C, а для обращения к объектам Python - вызовы Python/C API. Таким образом, объединяется выразительность Python и эффективность C. Конечно, некоторые вещи в Pyrex не доступны, например, генераторы, списковые включения и Unicode, однако, цель Pyrex - создание быстродействующих модулей расширения, и для этого он превосходно подходит. Ознакомится с Pyrex можно по документации (которая, к сожалению, есть пока только на английском языке).
</string>


    <string name="question1_1_text">1) Какую из этих парадигм программирования язык Python не поддерживает?</string>
    <string name="question1_2_text">2) Со скольки модулей может состоять программа на языке Python?</string>
    <string name="question1_3_text">3) Что значит elif?</string>
    <string name="question1_4_text">4) Сколько видов циклов имеется в Python?</string>
    <string name="question1_5_text">5) Какой цикл иллюстрирует данный пример?
        \ns = \"abcdefghijklmnop\"
        \nwhile s != \"\":
        \nprint (s)
        \ns = s[1:-1]</string>
    <string name="question1_6_text">6) Что делает следующий пример?
        \nf = open(\"file.txt\", \"r\")
        \nwhile f:
        \nl = f.readline()
        \nif not l:
        \nbreak
        \nif len(l) > 5:
        \nprint l
        \nf.close()</string>
    <string name="question1_7_text">7) Что кроме True используют для обозначения истины на Python?</string>
    <string name="question1_8_text">8) Как программист может определять собственные функции на языке Python? </string>
    <string name="question1_9_text">9) Зачем применяется механизм исключений?</string>
    <string name="question1_10_text">10) Какой специальный оператор применяется для утверждений?</string>

    <string name="question2_1_text">1) Какими могут быть объекты в Python?</string>
    <string name="question2_2_text">2)	Специальные типы представленные в языке программирования Python:</string>
    <string name="question2_3_text">3)	Для чего служат два типа: int и long?</string>
    <string name="question2_4_text">4)	 Литерал мнимой части (complex) задается добавлением какой буквы?</string>
    <string name="question2_5_text">5)	Что представлено на примере?\nmy_re = r\"(\\d)=\\1\"</string>
    <string name="question2_6_text">6)	Как называется операция “+” показанная в примере?\n>>> \"A\" + \"B\"\n\'AB\'</string>
    <string name="question2_7_text">7)	Что подразумевает синтаксис len(s)?</string>
    <string name="question2_8_text">8)	Метод append(x) используется для…</string>
    <string name="question2_9_text">9)	Для получения отдельного элемента последовательности используются:</string>
    <string name="question2_10_text">10)	Операция is, is not нужна для:</string>

    <string name="question3_1_text">1)	Подключение модуля к программе на Python осуществляется с помощью какого оператора?</string>
    <string name="question3_2_text">2)	Из какой категории функции getattr, setattr, delattr, hasattr?</string>
    <string name="question3_3_text">3)	Что делает функция cmp(x, y)?</string>
    <string name="question3_4_text">4)	Модули pdb, hotshot, profile, unittest, pydoc необходимы для:</string>
    <string name="question3_5_text">5)	Какой модуль представлен в примере?
        \nimport sets
        \nA = sets.Set([1, 2, 3])
        \nB = sets.Set([2, 3, 4])
        \nprint A | B, A &amp; B, A - B, A ^ B
        \nfor i in A:
        \n if i in B:
        \n  print i</string>
    <string name="question3_6_text">6)	Какой объект не из модуля \"sys\"?</string>
    <string name="question3_7_text">7)	Функция eval() необходима для:</string>
    <string name="question3_8_text">8)	В значении какой переменной можно увидеть пути по которым Python ищет модули?</string>
    <string name="question3_9_text">9)	Какие функции демонстрирует данный пример:
        \n>>> s = \"abcde\"
        \n>>> s1 = \"abcde\"
        \n>>> s2 = \"ab\" + \"cde\"
        \n>>> print \"hash:\", hash(s), hash(s1), hash(s2)
        \nhash: -1332677140 -1332677140 -1332677140
        \n>>> print \"id:\", id(s), id(s1), id(s2)
        \nid: 1076618592 1076618592 1076618656</string>
    <string name="question3_10_text">10) Какая разница между функциями input() и raw_input()?</string>

    <string name="question4_1_text">1)	Что такое Функциональное программирование? </string>
    <string name="question4_2_text">2)	Какую функцию демонстрирует данный пример?
        \ndef max_min(*args):
        \n# args - список аргументов в порядке их указания при вызове
        \nreturn max(args), min(args)
        \nprint max_min(1, 2, -1, 5, 3)</string>
    <string name="question4_3_text">3)	Сколько значения может возвратить функция в языке Python?</string>
    <string name="question4_4_text">4)	Что происходит при рекурсии в Python:</string>
    <string name="question4_5_text">5)	Что подразумевается под последовательностью в Python ?</string>
    <string name="question4_6_text">6)	Тип данных основной задачей которого является хранение называется:</string>
    <string name="question4_7_text">7)	Сколько аргументов принимает функция range ()?</string>
    <string name="question4_8_text">8)	Какой из этих аргументов не принимает функция reduce()?</string>
    <string name="question4_9_text">9)	Что необходимо сделать для получения итератора по некоторому объекту?</string>
    <string name="question4_10_text">10)	Отличие функции itertools.imap() от itertools.starmap() заключается в том, что:</string>

    <string name="question5_1_text">1)	Какой из следующих принципов Python правильный?</string>
    <string name="question5_2_text">2)	Каким значением не должен обладать объект (с точки зрения объектно-ориентированного подхода)?</string>
    <string name="question5_3_text">3)	Что определяют методы?</string>
    <string name="question5_4_text">4)	С помощью какой функции можно узнать набор методов некоторого объекта?</string>
    <string name="question5_5_text">5)	В каком случае вызывается деструктор?</string>
    <string name="question5_6_text">6)	Как можно выяснить принадлежность определённого данного к классу?</string>
    <string name="question5_7_text">7)	Инкапсуляцией называется:</string>
    <string name="question5_8_text">8)	Какой из этих специальных методов используется для удаления атрибута?</string>
    <string name="question5_9_text">9)	Полиморфизм это: </string>
    <string name="question5_10_text">10) Какой из параметров множественного наследования не верный?</string>

    <string name="question6_1_text">1)	Какое средство не имеет Numeric Python?</string>
    <string name="question6_2_text">2)	Для создания массива используем функцию:</string>
    <string name="question6_3_text">3)	В чём разница между asarray() и array()?</string>
    <string name="question6_4_text">4)	Какой функцией можно придать форму массиву?</string>
    <string name="question6_5_text">5)	Разница между функцией Numeric.resize() и Numeric.reshape() заключается в:</string>
    <string name="question6_6_text">6)	Из каких чисел Numeric.zeros() порождает массив?</string>
    <string name="question6_7_text">7)	Чьим аналогом является функция Numeric.arrayrange?</string>
    <string name="question6_8_text">8)	Какая из этих универсальных функций отвечает за получение остатка от деления?</string>
    <string name="question6_9_text">9)	Какая из заданных функций является аналогом функции  logical_and.reduce(a, axis)?</string>
    <string name="question6_10_text">10)	Какой аргумент не имеет функция Numeric.diagonal() ?</string>

    <string name="question7_1_text">1)	Для работы с каким форматом файлов предназначены эти 2 функции?\nreader(csvfile[, dialect=\'excel\'[, fmtparam]])</string>
    <string name="question7_2_text">2)	Где наиболее часто применяется RFC 2822?</string>
    <string name="question7_3_text">3)	Какой из представленных ниже модулей отвечает за работу с полями, в которых используется кодировка, отличная от ASCII?</string>
    <string name="question7_4_text">4)	Этот пример наиболее употребительных методов экземпляра для какого класса?
        \n>>> import email
        \n>>> input_file = open(\"pr1.eml\")
        \n>>> msg = email.message_from_file(input_file)</string>
    <string name="question7_5_text">5)	Что делает функция make_header()?</string>
    <string name="question7_6_text">6)	Какой подкласс используется для создания MIME-сообщений с графическим изображением?</string>
    <string name="question7_7_text">7)	Сколько путей обработки XML-документа существует?</string>
    <string name="question7_8_text">8)	Что делает функция output_tree()?</string>
    <string name="question7_9_text">9)	Экземплярами каких подклассов класса являются узлы?</string>
    <string name="question7_10_text">10)	Текстовый узел создаётся при помощи метода:</string>

    <string name="question8_1_text">1)	Сколько существует уровней моделей OSI?</string>
    <string name="question8_2_text">2)	Какой из этих уровней моделей OSI отвечает за маршрутизацию информационных пакетов от узла к узлу?</string>
    <string name="question8_3_text">3)	В каком из вариантов правильно создали объект для управления SMTP-сессией?</string>
    <string name="question8_4_text">4)	Какое исключени при работе с классом smtplib.SMTP не верное?</string>
    <string name="question8_5_text">5)	Какой из методов экземпляров класса POP3 отвечает за отмену пометок удаления сообщений?</string>
    <string name="question8_6_text">6)	Какого метода у объекта созданного благодаря функции urllib.urlopen() не существует?</string>
    <string name="question8_7_text">7)	Какой шаблон для построения URL верный?</string>
    <string name="question8_8_text">8)	Что в шаблоне построения URL (scheme://netloc/path;parameters?query#fragment) отвечает за путь к ресурсам?</string>
    <string name="question8_9_text">9)	Функция urllib.urlretrieve() вызывает время от времени другую интерактивную функцию, которая в свою очередь имеет 3 аргумента, какой из ниже представленных аргументов неверный?</string>
    <string name="question8_10_text">10)	За что отвечает функция fragment в строке URL?</string>

    <string name="question9_1_text">1)	Какой из параметров не должен иметь конструктор?</string>
    <string name="question9_2_text">2)	Какая из этих констант отвечает за использование знаков \"?\" для пометки мест подстановки параметров?</string>
    <string name="question9_3_text">3)	threadsafety - целочисленная константа, описывающая возможности модуля при использовании потоков управления, какое из этих описаний не верно?</string>
    <string name="question9_4_text">4)	Какой из этих обозначений типичных исключительных ситуаций выскочит за ошибку в работе или сбое соединения с базой данных?</string>
    <string name="question9_5_text">5)	Какой из этих методов не обязан иметь объект-соединение?</string>
    <string name="question9_6_text">6)	Атрибут объекта-курсора description нужен для:</string>
    <string name="question9_7_text">7)	Объект ROWID имеет тип:</string>
    <string name="question9_8_text">8)	Какого конструктора не существует?</string>
    <string name="question9_9_text">9)	Какая из представленных СУБД не совместима с Python?</string>
    <string name="question9_10_text">10)	Какое из действия описанных ниже не понадобится при работе с базой данных?</string>

    <string name="question10_1_text">1)	Макросы (Py_INCREF(), Py_DECREF(), Py_XINCREF(), Py_XDECREF(), Py_CLEAR()) необходимы для:</string>
    <string name="question10_2_text">2)	Поддержка анализа строки аргументов выполняется при помощи таких макросов:</string>
    <string name="question10_3_text">3)	PyObject и PyVarObject необходим для:</string>
    <string name="question10_4_text">4)	Опция pic порождает код, который:</string>
    <string name="question10_5_text">5)	Какую опцию необходимо передать компоновщику для того, чтобы исполняемый файл мог корректно предоставлять имена для динамически загружаемых модулей?</string>
    <string name="question10_6_text">6)	Для преобразования массива целых чисел в кортеж элементов типа long, необходимо:</string>
    <string name="question10_7_text">7)	Что выполняет функция показанная в примере?
        \n>>> import freq
        \n>>> for i in xrange(1000000):
        \n…   dummy =  freq.frequency(\"ABCDEF\")
        \n>>></string>
    <string name="question10_8_text">8)	Что сказанное ниже про Jython неверно?</string>
    <string name="question10_9_text">9)	Что чаще всего приводит к утечке памяти в Python?</string>
    <string name="question10_10_text">10) Какой язык программирования мы изучали?</string>

    <string name="answer1_1_1_text">Императивная</string>
    <string name="answer1_1_2_text">Функциональная</string>
    <string name="answer1_1_3_text">Логическая</string>
    <string name="answer1_1_4_text">Объектно-ориентированная</string>

    <string name="answer1_2_1_text">Только из 1</string>
    <string name="answer1_2_2_text">1 или несколько</string>
    <string name="answer1_2_3_text">2</string>
    <string name="answer1_2_4_text">Больше 3</string>

    <string name="answer1_3_1_text">сокращенный else if</string>
    <string name="answer1_3_2_text">случайное слово</string>
    <string name="answer1_3_3_text">встроенный тип данных</string>
    <string name="answer1_3_4_text">механизм исключений</string>

    <string name="answer1_4_1_text">0</string>
    <string name="answer1_4_2_text">1</string>
    <string name="answer1_4_3_text">2</string>
    <string name="answer1_4_4_text">3</string>

    <string name="answer1_5_1_text">Цикл ДЛЯ</string>
    <string name="answer1_5_2_text">Цикл ПОКА </string>
    <string name="answer1_5_3_text">Совместный цикл</string>
    <string name="answer1_5_4_text">Цикл Do</string>

    <string name="answer1_6_1_text">Читает строки из файла и выводит те, у которых длина больше 5</string>
    <string name="answer1_6_2_text">Читает строки из файла и выводит все</string>
    <string name="answer1_6_3_text">Читает строки из файла, а затем удаляет ненужные</string>
    <string name="answer1_6_4_text">Открывает файл file.txt и удаляет все строки</string>

    <string name="answer1_7_1_text">False</string>
    <string name="answer1_7_2_text">0</string>
    <string name="answer1_7_3_text">1</string>
    <string name="answer1_7_4_text">2</string>

    <string name="answer1_8_1_text">с помощью оператора def</string>
    <string name="answer1_8_2_text">прямо в выражении, посредством lambda</string>
    <string name="answer1_8_3_text">с помощью оператора def или же прямо в выражении, посредством lambda </string>
    <string name="answer1_8_4_text">никак</string>

    <string name="answer1_9_1_text">Для обработки особых ситуаций</string>
    <string name="answer1_9_2_text">Для объединения данных и кода</string>
    <string name="answer1_9_3_text">Для решения двух или более схожих, но технически разных задач</string>
    <string name="answer1_9_4_text">Он не используется в Python</string>

    <string name="answer1_10_1_text">Assert</string>
    <string name="answer1_10_2_text">Volatile</string>
    <string name="answer1_10_3_text">Mutable</string>
    <string name="answer1_10_4_text">Accept</string>


    <string name="answer2_1_1_text">неизменчивыми</string>
    <string name="answer2_1_2_text">неодушевлёнными</string>
    <string name="answer2_1_3_text">неизменчивыми и изменчивыми</string>
    <string name="answer2_1_4_text">изменчивыми</string>

    <string name="answer2_2_1_text">None, NotImplemented и Ellipsis</string>
    <string name="answer2_2_2_text">None, Implemented и Ellipsis</string>
    <string name="answer2_2_3_text">Spare, NotImplemented и Ellipsis</string>
    <string name="answer2_2_4_text">None, NotImplemented и Eclipse</string>

    <string name="answer2_3_1_text">Для представления списка</string>
    <string name="answer2_3_2_text">Для представления чисел</string>
    <string name="answer2_3_3_text">Для представления модулей</string>
    <string name="answer2_3_4_text">Для представления unicode-строки</string>

    <string name="answer2_4_1_text">Буквой u</string>
    <string name="answer2_4_2_text">Буквой g</string>
    <string name="answer2_4_3_text">Буквой j </string>
    <string name="answer2_4_4_text">Буквой k</string>

    <string name="answer2_5_1_text">Необработанный строковый литерал </string>
    <string name="answer2_5_2_text">Обработанный строковый литерал</string>
    <string name="answer2_5_3_text">Изменчивый строковый литерал</string>
    <string name="answer2_5_4_text">Неизменчевый строковый литерал</string>

    <string name="answer2_6_1_text">Повтор</string>
    <string name="answer2_6_2_text">Конкатенация</string>
    <string name="answer2_6_3_text">Форматирование</string>
    <string name="answer2_6_4_text">Плюс</string>

    <string name="answer2_7_1_text">Длина последовательности с</string>
    <string name="answer2_7_2_text">Длина последовательности s</string>
    <string name="answer2_7_3_text">Ширина последовательности s</string>
    <string name="answer2_7_4_text">Конкатенация последовательностей</string>

    <string name="answer2_8_1_text">Считывания количества элементов</string>
    <string name="answer2_8_2_text">Добавления элемента в конец последовательности</string>
    <string name="answer2_8_3_text">Добавления к концу последовательности последовательность х</string>
    <string name="answer2_8_4_text">Замены порядка элементов х на обратный</string>

    <string name="answer2_9_1_text">Круглые скобки</string>
    <string name="answer2_9_2_text">Квадратные скобки</string>
    <string name="answer2_9_3_text">Точка с запятой</string>
    <string name="answer2_9_4_text">Знак восклицания</string>

    <string name="answer2_10_1_text">Проверки принадлежности</string>
    <string name="answer2_10_2_text">Проверки идентичности </string>
    <string name="answer2_10_3_text">Проверки исключения</string>
    <string name="answer2_10_4_text">Проверки преобразования строк</string>


    <string name="answer3_1_1_text">module</string>
    <string name="answer3_1_2_text">import</string>
    <string name="answer3_1_3_text">add</string>
    <string name="answer3_1_4_text">for</string>

    <string name="answer3_2_1_text">Функции ввода-вывода</string>
    <string name="answer3_2_2_text">Функции определения свойств</string>
    <string name="answer3_2_3_text">Функции для работы с атрибутами</string>
    <string name="answer3_2_4_text">Функции преобразования типов и классы</string>

    <string name="answer3_3_1_text">Округление чисел до заданного знака после (или до) точки</string>
    <string name="answer3_3_2_text">Функция возвращает код</string>
    <string name="answer3_3_3_text">Возвращает число элементов последовательности или отображения</string>
    <string name="answer3_3_4_text">Сравнение двух значений</string>

    <string name="answer3_4_1_text">Поддержки цикла разработки </string>
    <string name="answer3_4_2_text">Обработки текстов</string>
    <string name="answer3_4_3_text">Хранения данных</string>
    <string name="answer3_4_4_text">Поддержки сети</string>

    <string name="answer3_5_1_text">Модуль sets</string>
    <string name="answer3_5_2_text">Модуль copy</string>
    <string name="answer3_5_3_text">Модуль print</string>
    <string name="answer3_5_4_text">Модуль for</string>

    <string name="answer3_6_1_text">Argv</string>
    <string name="answer3_6_2_text">exc_info()</string>
    <string name="answer3_6_3_text">version</string>
    <string name="answer3_6_4_text">cosh(x)</string>

    <string name="answer3_7_1_text">Вычисления переданного ей выражения</string>
    <string name="answer3_7_2_text">Сравнивания двух значения</string>
    <string name="answer3_7_3_text">Возвращения таблиц локальных имен некоторого объекта</string>
    <string name="answer3_7_4_text">Модуль числа x</string>

    <string name="answer3_8_1_text">sys.path</string>
    <string name="answer3_8_2_text">sys</string>
    <string name="answer3_8_3_text">sys.eval</string>
    <string name="answer3_8_4_text">sys.pathern</string>

    <string name="answer3_9_1_text">Функции определения свойств</string>
    <string name="answer3_9_2_text">Функции для доступа к внутренним структурам</string>
    <string name="answer3_9_3_text">Числовые и строковые функции</string>
    <string name="answer3_9_4_text">Функции для работы с атрибутами</string>

    <string name="answer3_10_1_text">raw_input() берет именно то, что пользователь вводил и передавал обратно в виде строки</string>
    <string name="answer3_10_2_text">Разница только лишь в названии функций</string>
    <string name="answer3_10_3_text">raw_input() сначала берет input(), а затем выполняет также eval()</string>
    <string name="answer3_10_4_text">Разницы между этими функциями нету</string>


    <string name="answer4_1_1_text">Это стиль программирования, основанный на автоматическом доказательстве теорем</string>
    <string name="answer4_1_2_text">Это стиль программирования, основанный на идее разделения функциональности</string>
    <string name="answer4_1_3_text">Это стиль программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы</string>
    <string name="answer4_1_4_text">Это стиль программирования, использующий только композиции функций</string>

    <string name="answer4_2_1_text">Функция двух аргументов, один из которых необязателен и имеет значение по умолчанию</string>
    <string name="answer4_2_2_text">Функция произвольного числа аргументов </string>
    <string name="answer4_2_3_text">Функция с обычными (позиционными) и именованными аргументами</string>
    <string name="answer4_2_4_text">Функция с одним обязательным аргументом, с одним, имеющим значение по умолчанию и неопределенным числом именованных аргументов</string>

    <string name="answer4_3_1_text">0</string>
    <string name="answer4_3_2_text">1</string>
    <string name="answer4_3_3_text">2</string>
    <string name="answer4_3_4_text">3</string>

    <string name="answer4_4_1_text">Функция вызывает сама себя </string>
    <string name="answer4_4_2_text">Функция возвращает одно значение.</string>
    <string name="answer4_4_3_text">Определения функции</string>
    <string name="answer4_4_4_text">Обработка массивов</string>

    <string name="answer4_5_1_text">Числа которые поддерживают интерфейс последовательно</string>
    <string name="answer4_5_2_text">Строки которые поддерживают интерфейс последовательности</string>
    <string name="answer4_5_3_text">Любой тип данных которые поддерживают интерфейс последовательности </string>
    <string name="answer4_5_4_text">Логические переменные которые поддерживают интерфейс последовательности</string>

    <string name="answer4_6_1_text">Контейнером</string>
    <string name="answer4_6_2_text">Пакетом</string>
    <string name="answer4_6_3_text">Закрытым типом</string>
    <string name="answer4_6_4_text">Банковый тип</string>

    <string name="answer4_7_1_text">От 1 до 2</string>
    <string name="answer4_7_2_text">От 1 до 3 </string>
    <string name="answer4_7_3_text">От 1 до 5</string>
    <string name="answer4_7_4_text">От 1 до …</string>

    <string name="answer4_8_1_text">Функцию двух аргументов</string>
    <string name="answer4_8_2_text">Последовательность</string>
    <string name="answer4_8_3_text">Функцию с условием</string>
    <string name="answer4_8_4_text">Начальное значение</string>

    <string name="answer4_9_1_text">Применить к этому объекту функцию iter() </string>
    <string name="answer4_9_2_text">Применить к этому объекту функцию join() </string>
    <string name="answer4_9_3_text">Использовать None в качестве первого аргумента</string>
    <string name="answer4_9_4_text">Использовать map в качестве первого аргумента</string>

    <string name="answer4_10_1_text">Вместо значения от преждевременно завершившихся итераторов объект None подставляется</string>
    <string name="answer4_10_2_text">Вместо значения от преждевременно завершившихся итераторов объект None не подставляется</string>
    <string name="answer4_10_3_text">Отличий кроме названия функций нету</string>
    <string name="answer4_10_4_text">imap() нормально воспринимает итераторы в любом сочетании с итерабельными в отличии от starmap()</string>


    <string name="answer5_1_1_text">Все данные в нем представляются классами</string>
    <string name="answer5_1_2_text">Каждый объект имеет собственную часть памяти и не может состоять из других объектов</string>
    <string name="answer5_1_3_text">Каждый объект имеет тип </string>
    <string name="answer5_1_4_text">Все объекты одного типа не могут принимать одни и те же сообщения (и выполнять одни и те же действия)</string>

    <string name="answer5_2_1_text">Индивидуальностью</string>
    <string name="answer5_2_2_text">Типом</string>
    <string name="answer5_2_3_text">Значением</string>
    <string name="answer5_2_4_text">Динамичностью</string>

    <string name="answer5_3_1_text">Поведение объекта</string>
    <string name="answer5_3_2_text">Атрибуты объекта</string>
    <string name="answer5_3_3_text">Состояние объекта</string>
    <string name="answer5_3_4_text">Операции над объектами</string>

    <string name="answer5_4_1_text">dir()</string>
    <string name="answer5_4_2_text">abs()</string>
    <string name="answer5_4_3_text">import()</string>
    <string name="answer5_4_4_text">def()</string>

    <string name="answer5_5_1_text">При создании нового объекта</string>
    <string name="answer5_5_2_text">При уничтожении объекта</string>
    <string name="answer5_5_3_text">При вызове через синтаксис в любом случае</string>
    <string name="answer5_5_4_text">При создании нового объекта, а затем при помощи синтаксиса</string>

    <string name="answer5_6_1_text">С помощью встроенной функции isinstance()</string>
    <string name="answer5_6_2_text">С помощью встроенной функции  __str__()</string>
    <string name="answer5_6_3_text">С помощью встроенной функции setx()</string>
    <string name="answer5_6_4_text">С помощью встроенной функции abs()</string>

    <string name="answer5_7_1_text">Показ информации о внутреннем устройстве объекта, при котором работа с объектом может вестись только через его общедоступный интерфейс </string>
    <string name="answer5_7_2_text">Сокрытие информации о внутреннем устройстве объекта, при котором работа с объектом может вестись только через его общедоступный интерфейс </string>
    <string name="answer5_7_3_text">Создание специальных методов</string>
    <string name="answer5_7_4_text">Обрабатотка запроса на доступ к атрибуту</string>

    <string name="answer5_8_1_text">__delattr__(self, name)</string>
    <string name="answer5_8_2_text">__setattr__(self, name, value)</string>
    <string name="answer5_8_3_text">__getattr__(self, name)</string>
    <string name="answer5_8_4_text">_selfdict[name]</string>

    <string name="answer5_9_1_text">Возможность использования различных имен для выполнения одного действия</string>
    <string name="answer5_9_2_text">Возможность использования одного имени для выполнения различных действий</string>
    <string name="answer5_9_3_text">Возможность использования одного имени для выполнения одного действия</string>
    <string name="answer5_9_4_text">Получение доступа к некоторому атрибуту (не методу) напрямую</string>

    <string name="answer5_10_1_text">Множественное наследование можно применить для получения класса с заданными общедоступными методами, причем методы задает один родительский класс, а реализуются они на основе методов второго класса. </string>
    <string name="answer5_10_2_text">Множественное наследование применяется для добавления примесей (mixins). Примесь - специально сконструированный класс, добавляющий в некоторый класс какую-либо черту поведения (привнесением атрибутов). Примеси обычно являются абстрактными классами.</string>
    <string name="answer5_10_3_text">Изредка множественное наследование применяется в своем основном смысле, когда объекты класса, получающегося в результате множественного наследования, предназначаются для использования в качестве объектов всех родительских классов.</string>
    <string name="answer5_10_4_text">Первый класс не может быть полностью абстрактным</string>


    <string name="answer6_1_1_text">Быстрого преобразования Фурье FFT</string>
    <string name="answer6_1_2_text">Матричных вычислений LinearAlgebra</string>
    <string name="answer6_1_3_text">Эмуляции базовых функций программы MatLab</string>
    <string name="answer6_1_4_text">Калькулятор целых чисел</string>

    <string name="answer6_2_1_text">array()</string>
    <string name="answer6_2_2_text">Numeric.reshape()</string>
    <string name="answer6_2_3_text">tolist()</string>
    <string name="answer6_2_4_text">add(x, y)</string>

    <string name="answer6_3_1_text">В названии функции</string>
    <string name="answer6_3_2_text">В том, что asarray() не создает нового массива, когда ее аргумент уже является массивом</string>
    <string name="answer6_3_3_text">В том, что asarray() создает ещё один новый массив, когда его аргумент является массивом</string>
    <string name="answer6_3_4_text">asarray() предлагает более широкий спектр опций, нежели array()</string>

    <string name="answer6_4_1_text">Numeric.reshape()</string>
    <string name="answer6_4_2_text">Numeric.arrayrange() </string>
    <string name="answer6_4_3_text">reduce()</string>
    <string name="answer6_4_4_text">reduceat()</string>

    <string name="answer6_5_1_text">Названии функции</string>
    <string name="answer6_5_2_text">Numeric.resizе может подстраивать число элементов в отличии от Numeric.reshape</string>
    <string name="answer6_5_3_text">Numeric.reshape() порождает массив из одних нулей</string>
    <string name="answer6_5_4_text">Numeric.reshape может подстраивать число элементов в отличии от Numeric.resize</string>

    <string name="answer6_6_1_text">0</string>
    <string name="answer6_6_2_text">1</string>
    <string name="answer6_6_3_text">2</string>
    <string name="answer6_6_4_text">Любых</string>

    <string name="answer6_7_1_text">copy()</string>
    <string name="answer6_7_2_text">tolist()</string>
    <string name="answer6_7_3_text">range()</string>
    <string name="answer6_7_4_text">add()</string>

    <string name="answer6_8_1_text">multiply(x, y), divide(x, y)</string>
    <string name="answer6_8_2_text">remainder(x, y), fmod(x, y)</string>
    <string name="answer6_8_3_text">absolute(x), fabs(x)</string>
    <string name="answer6_8_4_text">ceil(x), floor(x)</string>

    <string name="answer6_9_1_text">alltrue(a, axis)</string>
    <string name="answer6_9_2_text">sometrue(a, axis)</string>
    <string name="answer6_9_3_text">product(a, axis)</string>
    <string name="answer6_9_4_text">cumsum(a, axis)</string>

    <string name="answer6_10_1_text">Offset</string>
    <string name="answer6_10_2_text">axis1</string>
    <string name="answer6_10_3_text">axis2</string>
    <string name="answer6_10_4_text">axis3</string>


    <string name="answer7_1_1_text">CSV</string>
    <string name="answer7_1_2_text">XML</string>
    <string name="answer7_1_3_text">Unix</string>
    <string name="answer7_1_4_text">Mailbox</string>

    <string name="answer7_2_1_text">В работе с файлами формата CSV</string>
    <string name="answer7_2_2_text">В сообщениях электронной почты в Интернете</string>
    <string name="answer7_2_3_text">При работе с файлами формата XML</string>
    <string name="answer7_2_4_text">При работе с MailBox</string>

    <string name="answer7_3_1_text">Message</string>
    <string name="answer7_3_2_text">Parser</string>
    <string name="answer7_3_3_text">Header</string>
    <string name="answer7_3_4_text">Generator</string>

    <string name="answer7_4_1_text">Message</string>
    <string name="answer7_4_2_text">Parser</string>
    <string name="answer7_4_3_text">Generator</string>
    <string name="answer7_4_4_text">Header</string>

    <string name="answer7_5_1_text">Создаёт новый заголовок в сообщении</string>
    <string name="answer7_5_2_text">Редактирует заголовок в сообщении</string>
    <string name="answer7_5_3_text">Кодирует содержимое для заголовка</string>
    <string name="answer7_5_4_text">Отправляет заголовок вместо сообщения</string>

    <string name="answer7_6_1_text">class MIMEText(_text[, _subtype[, _charset]])</string>
    <string name="answer7_6_2_text">class MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])</string>
    <string name="answer7_6_3_text">class MIMEMessage(_msg[, _subtype])</string>
    <string name="answer7_6_4_text">class MIMEMultipart([_subtype[, boundary[, _subparts[, _params]]]])</string>

    <string name="answer7_7_1_text">1</string>
    <string name="answer7_7_2_text">2</string>
    <string name="answer7_7_3_text">3</string>
    <string name="answer7_7_4_text">Больше 3</string>

    <string name="answer7_8_1_text">Принимает на входе узел и вызывается рекурсивно для всех вложенных узлов </string>
    <string name="answer7_8_2_text">Принимает на входе узел и вызывается нерекурсивно для всех вложенных узлов</string>
    <string name="answer7_8_3_text">Принимает на входе большое количество узлов и вызывается рекурсивно для всех вложенных узлов</string>
    <string name="answer7_8_4_text">Принимает на входе узел и вызывается рекурсивно для всех узлов вне зависимости от их состояния (вложенные или нет и т.д.)</string>

    <string name="answer7_9_1_text">Dom</string>
    <string name="answer7_9_2_text">Node</string>
    <string name="answer7_9_3_text">MDX</string>
    <string name="answer7_9_4_text">Trix</string>

    <string name="answer7_10_1_text">createElement(tagname)</string>
    <string name="answer7_10_2_text">createAttribute(name)</string>
    <string name="answer7_10_3_text">createTextNode(data)</string>
    <string name="answer7_10_4_text">createComment(comment)</string>


    <string name="answer8_1_1_text">2</string>
    <string name="answer8_1_2_text">4</string>
    <string name="answer8_1_3_text">5</string>
    <string name="answer8_1_4_text">7</string>

    <string name="answer8_2_1_text">Канальный</string>
    <string name="answer8_2_2_text">Сетевой</string>
    <string name="answer8_2_3_text">Транспортный</string>
    <string name="answer8_2_4_text">Сеансовый</string>

    <string name="answer8_3_1_text">smtplib.SMTP([, port])</string>
    <string name="answer8_3_2_text">smtplib.SM([host[, port]])</string>
    <string name="answer8_3_3_text">smtplib.SMTP([host[, port]])</string>
    <string name="answer8_3_4_text">smtp.SMTP([host[, port]])</string>

    <string name="answer8_4_1_text">smtplib.SMTPException</string>
    <string name="answer8_4_2_text">smtplib.SMTPServerDisconnected</string>
    <string name="answer8_4_3_text">smtplib.SMTPResponseException</string>
    <string name="answer8_4_4_text">smtplib.SMTPRecipientsDeleted</string>

    <string name="answer8_5_1_text">dele(num)</string>
    <string name="answer8_5_2_text">rset()</string>
    <string name="answer8_5_3_text">list([num])</string>
    <string name="answer8_5_4_text">apop(user, secret)</string>

    <string name="answer8_6_1_text">readline()</string>
    <string name="answer8_6_2_text">readlines()</string>
    <string name="answer8_6_3_text">fileno()</string>
    <string name="answer8_6_4_text">open()</string>

    <string name="answer8_7_1_text">scheme//netloc/path;parameters?query#fragment</string>
    <string name="answer8_7_2_text">scheme://netloc/path;#fragment</string>
    <string name="answer8_7_3_text">scheme//netloc/path;parameters</string>
    <string name="answer8_7_4_text">scheme://netloc/path;parameters?query#fragment</string>

    <string name="answer8_8_1_text">params</string>
    <string name="answer8_8_2_text">netloc</string>
    <string name="answer8_8_3_text">path</string>
    <string name="answer8_8_4_text">query</string>

    <string name="answer8_9_1_text">Количество принятых блоков</string>
    <string name="answer8_9_2_text">Размер блока</string>
    <string name="answer8_9_3_text">Количество отправленных блоков</string>
    <string name="answer8_9_4_text">Общий размер принимаемого объекта в байтах</string>

    <string name="answer8_10_1_text">Строка запроса</string>
    <string name="answer8_10_2_text">Идентификатор фрагмента</string>
    <string name="answer8_10_3_text">Параметры фрагмента</string>
    <string name="answer8_10_4_text">Адресная схема</string>

    <string name="answer9_1_1_text">Dsn</string>
    <string name="answer9_1_2_text">Host</string>
    <string name="answer9_1_3_text">User</string>
    <string name="answer9_1_4_text">E-Mail</string>

    <string name="answer9_2_1_text">qmark</string>
    <string name="answer9_2_2_text">format</string>
    <string name="answer9_2_3_text">named</string>
    <string name="answer9_2_4_text">pyformat</string>

    <string name="answer9_3_1_text">Модуль поддерживает потоки</string>
    <string name="answer9_3_2_text">Потоки могут совместно использовать модуль, но не соединения</string>
    <string name="answer9_3_3_text">Потоки могут совместно использовать модуль и соединения</string>
    <string name="answer9_3_4_text">Потоки могут совместно использовать модуль и соединения. Потоки могут совместно использовать модуль, соединения и курсоры. (Под совместным использованием здесь понимается возможность использования упомянутых ресурсов без применения семафоров)</string>

    <string name="answer9_4_1_text">IntegrityError</string>
    <string name="answer9_4_2_text">OperationalError</string>
    <string name="answer9_4_3_text">ProgrammingError</string>
    <string name="answer9_4_4_text">DatabaseError</string>

    <string name="answer9_5_1_text">close()</string>
    <string name="answer9_5_2_text">commit()</string>
    <string name="answer9_5_3_text">rollback()</string>
    <string name="answer9_5_4_text">open()</string>

    <string name="answer9_6_1_text">Вызова хранимой процедуры procname с параметрами из изменчивой последовательности params </string>
    <string name="answer9_6_2_text">Атрибут, равный количеству записей, возвращаемых методом fetchmany() нужен для хранения информации</string>
    <string name="answer9_6_3_text">Исполнения запроса к базе данных или команде СУБД</string>
    <string name="answer9_6_4_text">Выполнения серии запросов или команд, подставляя параметры в заданный шаблон</string>

    <string name="answer9_7_1_text">Строка и символ</string>
    <string name="answer9_7_2_text">Идентификатор записи</string>
    <string name="answer9_7_3_text">Дата и время</string>
    <string name="answer9_7_4_text">Бинарный объект</string>

    <string name="answer9_8_1_text">DateFromTicks</string>
    <string name="answer9_8_2_text">TimeFromTicks</string>
    <string name="answer9_8_3_text">HourFromTicks</string>
    <string name="answer9_8_4_text">TimestampFromTicks</string>

    <string name="answer9_9_1_text">MySQL</string>
    <string name="answer9_9_2_text">DCOracle2</string>
    <string name="answer9_9_3_text">Sybase</string>
    <string name="answer9_9_4_text">PythonBase</string>

    <string name="answer9_10_1_text">Создание одного или нескольких курсоров</string>
    <string name="answer9_10_2_text">Исполнение команды или запроса</string>
    <string name="answer9_10_3_text">Получение результатов запроса </string>
    <string name="answer9_10_4_text">Настройка соединения для хранения информации в БД</string>

    <string name="answer10_1_1_text">Управление подсчетом ссылок </string>
    <string name="answer10_1_2_text">Обработка исключений</string>
    <string name="answer10_1_3_text">Функции для работы со встроенным интерпретатором и потоками</string>
    <string name="answer10_1_4_text">Управление процессом и сервисы операционной системы</string>

    <string name="answer10_2_1_text">PyObject_Print(), PyObject_HasAttrString(), PyObject_GetAttrString(), PyObject_HasAttr(), PyObject_GetAttr(), PyObject_RichCompare()</string>
    <string name="answer10_2_2_text">PyArg_ParseTuple(), PyArg_VaParse(), PyArg_ParseTupleAndKeywords(), PyArg_VaParseTupleAndKeywords(), PyArg_UnpackTuple() и Py_BuildValue() </string>
    <string name="answer10_2_3_text">PySequence_Check(), PySequence_Size(), PySequence_Concat(), PySequence_Repeat()</string>
    <string name="answer10_2_4_text">PyMapping_Check(), PyMapping_Length(), PyMapping_HasKey()</string>

    <string name="answer10_3_1_text">Управления памятью</string>
    <string name="answer10_3_2_text">Определения объектов встроенных типов </string>
    <string name="answer10_3_3_text">Поддержки встроенных типов данных</string>
    <string name="answer10_3_4_text">Поддержки протоколов абстрактных объектов</string>

    <string name="answer10_4_1_text">Зависит от позиции, что позволяет в дальнейшем динамически компоновать код</string>
    <string name="answer10_4_2_text">Не зависит от позиции и не позволяет в дальнейшем изменять код</string>
    <string name="answer10_4_3_text">Не зависит от позиции, что позволяет в дальнейшем динамически компоновать код</string>
    <string name="answer10_4_4_text">Зависит от позиции и не позволяет в дальнейшем изменять код</string>

    <string name="answer10_5_1_text">-E</string>
    <string name="answer10_5_2_text">-P</string>
    <string name="answer10_5_3_text">-G</string>
    <string name="answer10_5_4_text">-D</string>

    <string name="answer10_6_1_text">Освободить память из-под входящего массива</string>
    <string name="answer10_6_2_text">Освободить память из-под исходного массива, в котором подсчитывались частоты </string>
    <string name="answer10_6_3_text">Освободить память из-под исходного массива, в котором был компонован код</string>
    <string name="answer10_6_4_text">Освободить память из-под любого массива</string>

    <string name="answer10_7_1_text">Обнаруживает утечки памяти </string>
    <string name="answer10_7_2_text">Освобождает память из-под исходного массива</string>
    <string name="answer10_7_3_text">Компонует исходный код</string>
    <string name="answer10_7_4_text">Определяет объекты встроенных типов</string>

    <string name="answer10_8_1_text">Jython-код динамически компилирует байт-коды Java, хотя возможна и статическая компиляция, что позволяет писать апплеты, сервлеты и т.п.</string>
    <string name="answer10_8_2_text">Поддерживает объектно-ориентированную модель Java, в том числе, возможность наследовать от абстрактных Java-классов</string>
    <string name="answer10_8_3_text">Jython является реализацией Python - языка с практичным синтаксисом, обладающего большой выразительностью, что позволяет сократить сроки разработки приложений в разы</string>
    <string name="answer10_8_4_text">Jython может очень легко преобразовывает код Python в Java</string>

    <string name="answer10_9_1_text">Многократное использование PyMapping_Check() и PyMapping_Length()</string>
    <string name="answer10_9_2_text">Многократное использование PyArg_VaParse() и  PyArg_ParseTupleAndKeywords()</string>
    <string name="answer10_9_3_text">Многократное использование Py_Initialize() и Py_Finalize()</string>
    <string name="answer10_9_4_text">Многократное использование PyMapping_Check() и  PyMapping_Length()</string>

    <string name="answer10_10_1_text">Java</string>
    <string name="answer10_10_2_text">C++</string>
    <string name="answer10_10_3_text">Python</string>
    <string name="answer10_10_4_text">Pyrex</string>

    <string name="result_90_text">Вы сдали отлично</string>
    <string name="result_80_text">Вы сдали хорошо</string>
    <string name="result_60_text">Вы сдали\nудовлетворительно</string>
    <string name="result_0_text">Вы сдали\nнеудовлетворительно</string>

    <string name="titleLes">СПИСОК ЛЕКЦИЙ</string>
    <string name="titleRes">ЛУЧШИЙ\nРЕЗУЛЬТАТ</string>

</resources>
